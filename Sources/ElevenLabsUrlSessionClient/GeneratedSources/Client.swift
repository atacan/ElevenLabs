// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
import ElevenLabsTypes
/// This is the documentation for the ElevenLabs API. You can use this API to use our service programmatically, this is done by using your API key. You can find your API key in the dashboard at https://elevenlabs.io/app/settings/api-keys.
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Speech To Text
    ///
    /// Transcribe an audio or video file. If webhook is set to true, the request will be processed asynchronously and results sent to configured webhooks. When use_multi_channel is true and the provided audio has multiple channels, a 'transcripts' object with separate transcripts for each channel is returned. Otherwise, returns a single transcript. The optional webhook_metadata parameter allows you to attach custom data that will be included in webhook responses for request correlation and tracking.
    ///
    /// - Remark: HTTP `POST /v1/speech-to-text`.
    /// - Remark: Generated from `#/paths//v1/speech-to-text/post(Speech_to_Text_v1_speech_to_text_post)`.
    public func Speech_to_Text_v1_speech_to_text_post(_ input: Operations.Speech_to_Text_v1_speech_to_text_post.Input) async throws -> Operations.Speech_to_Text_v1_speech_to_text_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Speech_to_Text_v1_speech_to_text_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/speech-to-text",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enable_logging",
                    value: input.query.enable_logging
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "model_id"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "cloud_storage_url",
                            "diarization_threshold",
                            "diarize",
                            "file",
                            "file_format",
                            "language_code",
                            "num_speakers",
                            "seed",
                            "tag_audio_events",
                            "temperature",
                            "timestamps_granularity",
                            "use_multi_channel",
                            "webhook",
                            "webhook_id",
                            "webhook_metadata"
                        ],
                        zeroOrMoreTimesPartNames: [
                            "additional_formats"
                        ],
                        encoding: { part in
                            switch part {
                            case let .model_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "model_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .tag_audio_events(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "tag_audio_events",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .timestamps_granularity(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "timestamps_granularity",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .diarize(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "diarize",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .file_format(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "file_format",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .webhook(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "webhook",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .use_multi_channel(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "use_multi_channel",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .additional_formats(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsJSON(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "application/json; charset=utf-8"
                                )
                                return .init(
                                    name: "additional_formats",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .file(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "file",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .language_code(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "language_code",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .num_speakers(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "num_speakers",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .diarization_threshold(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "diarization_threshold",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .cloud_storage_url(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "cloud_storage_url",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .webhook_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "webhook_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .temperature(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "temperature",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .seed(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "seed",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .webhook_metadata(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsJSON(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "application/json; charset=utf-8"
                                )
                                return .init(
                                    name: "webhook_metadata",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Speech_to_Text_v1_speech_to_text_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.Speech_to_Text_v1_speech_to_text_post.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 202:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Speech_to_Text_v1_speech_to_text_post.Output.Accepted.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .accepted(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Speech_to_Text_v1_speech_to_text_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
