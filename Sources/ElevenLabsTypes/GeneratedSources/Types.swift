// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
/// A type that performs HTTP operations defined by the OpenAPI document.
public protocol APIProtocol: Sendable {
    /// Speech To Text
    ///
    /// Transcribe an audio or video file. If webhook is set to true, the request will be processed asynchronously and results sent to configured webhooks. When use_multi_channel is true and the provided audio has multiple channels, a 'transcripts' object with separate transcripts for each channel is returned. Otherwise, returns a single transcript. The optional webhook_metadata parameter allows you to attach custom data that will be included in webhook responses for request correlation and tracking.
    ///
    /// - Remark: HTTP `POST /v1/speech-to-text`.
    /// - Remark: Generated from `#/paths//v1/speech-to-text/post(Speech_to_Text_v1_speech_to_text_post)`.
    func Speech_to_Text_v1_speech_to_text_post(_ input: Operations.Speech_to_Text_v1_speech_to_text_post.Input) async throws -> Operations.Speech_to_Text_v1_speech_to_text_post.Output
}

/// Convenience overloads for operation inputs.
extension APIProtocol {
    /// Speech To Text
    ///
    /// Transcribe an audio or video file. If webhook is set to true, the request will be processed asynchronously and results sent to configured webhooks. When use_multi_channel is true and the provided audio has multiple channels, a 'transcripts' object with separate transcripts for each channel is returned. Otherwise, returns a single transcript. The optional webhook_metadata parameter allows you to attach custom data that will be included in webhook responses for request correlation and tracking.
    ///
    /// - Remark: HTTP `POST /v1/speech-to-text`.
    /// - Remark: Generated from `#/paths//v1/speech-to-text/post(Speech_to_Text_v1_speech_to_text_post)`.
    public func Speech_to_Text_v1_speech_to_text_post(
        query: Operations.Speech_to_Text_v1_speech_to_text_post.Input.Query = .init(),
        headers: Operations.Speech_to_Text_v1_speech_to_text_post.Input.Headers = .init(),
        body: Operations.Speech_to_Text_v1_speech_to_text_post.Input.Body
    ) async throws -> Operations.Speech_to_Text_v1_speech_to_text_post.Output {
        try await Speech_to_Text_v1_speech_to_text_post(Operations.Speech_to_Text_v1_speech_to_text_post.Input(
            query: query,
            headers: headers,
            body: body
        ))
    }
}

/// Server URLs defined in the OpenAPI document.
public enum Servers {}

/// Types generated from the components section of the OpenAPI document.
public enum Components {
    /// Types generated from the `#/components/schemas` section of the OpenAPI document.
    public enum Schemas {
        /// - Remark: Generated from `#/components/schemas/AdditionalFormatResponseModel`.
        public struct AdditionalFormatResponseModel: Codable, Hashable, Sendable {
            /// The requested format.
            ///
            /// - Remark: Generated from `#/components/schemas/AdditionalFormatResponseModel/requested_format`.
            public var requested_format: Swift.String
            /// The file extension of the additional format.
            ///
            /// - Remark: Generated from `#/components/schemas/AdditionalFormatResponseModel/file_extension`.
            public var file_extension: Swift.String
            /// The content type of the additional format.
            ///
            /// - Remark: Generated from `#/components/schemas/AdditionalFormatResponseModel/content_type`.
            public var content_type: Swift.String
            /// Whether the content is base64 encoded.
            ///
            /// - Remark: Generated from `#/components/schemas/AdditionalFormatResponseModel/is_base64_encoded`.
            public var is_base64_encoded: Swift.Bool
            /// The content of the additional format.
            ///
            /// - Remark: Generated from `#/components/schemas/AdditionalFormatResponseModel/content`.
            public var content: Swift.String
            /// Creates a new `AdditionalFormatResponseModel`.
            ///
            /// - Parameters:
            ///   - requested_format: The requested format.
            ///   - file_extension: The file extension of the additional format.
            ///   - content_type: The content type of the additional format.
            ///   - is_base64_encoded: Whether the content is base64 encoded.
            ///   - content: The content of the additional format.
            public init(
                requested_format: Swift.String,
                file_extension: Swift.String,
                content_type: Swift.String,
                is_base64_encoded: Swift.Bool,
                content: Swift.String
            ) {
                self.requested_format = requested_format
                self.file_extension = file_extension
                self.content_type = content_type
                self.is_base64_encoded = is_base64_encoded
                self.content = content
            }
            public enum CodingKeys: String, CodingKey {
                case requested_format
                case file_extension
                case content_type
                case is_base64_encoded
                case content
            }
        }
        /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post`.
        @frozen public enum Body_Speech_to_Text_v1_speech_to_text_post: Sendable, Hashable {
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/model_id`.
            public struct model_idPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `model_idPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case model_id(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.model_idPayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/tag_audio_events`.
            public struct tag_audio_eventsPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `tag_audio_eventsPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case tag_audio_events(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.tag_audio_eventsPayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/timestamps_granularity`.
            public struct timestamps_granularityPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `timestamps_granularityPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case timestamps_granularity(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.timestamps_granularityPayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/diarize`.
            public struct diarizePayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `diarizePayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case diarize(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.diarizePayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/file_format`.
            public struct file_formatPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `file_formatPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case file_format(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.file_formatPayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/webhook`.
            public struct webhookPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `webhookPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case webhook(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.webhookPayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/use_multi_channel`.
            public struct use_multi_channelPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `use_multi_channelPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case use_multi_channel(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.use_multi_channelPayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/additional_formats`.
            public struct additional_formatsPayload: Sendable, Hashable {
                public var body: Components.Schemas.ExportOptions
                /// Creates a new `additional_formatsPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: Components.Schemas.ExportOptions) {
                    self.body = body
                }
            }
            case additional_formats(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.additional_formatsPayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/file`.
            public struct filePayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `filePayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case file(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.filePayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/language_code`.
            public struct language_codePayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `language_codePayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case language_code(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.language_codePayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/num_speakers`.
            public struct num_speakersPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `num_speakersPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case num_speakers(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.num_speakersPayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/diarization_threshold`.
            public struct diarization_thresholdPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `diarization_thresholdPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case diarization_threshold(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.diarization_thresholdPayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/cloud_storage_url`.
            public struct cloud_storage_urlPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `cloud_storage_urlPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case cloud_storage_url(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.cloud_storage_urlPayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/webhook_id`.
            public struct webhook_idPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `webhook_idPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case webhook_id(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.webhook_idPayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/temperature`.
            public struct temperaturePayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `temperaturePayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case temperature(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.temperaturePayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/seed`.
            public struct seedPayload: Sendable, Hashable {
                public var body: OpenAPIRuntime.HTTPBody
                /// Creates a new `seedPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: OpenAPIRuntime.HTTPBody) {
                    self.body = body
                }
            }
            case seed(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.seedPayload>)
            /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/webhook_metadata`.
            public struct webhook_metadataPayload: Sendable, Hashable {
                /// Optional metadata to be included in the webhook response. This should be a JSON string representing an object with a maximum depth of 2 levels and maximum size of 16KB. Useful for tracking internal IDs, job references, or other contextual information.
                ///
                /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/webhook_metadata/content/body`.
                public struct bodyPayload: Codable, Hashable, Sendable {
                    /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/webhook_metadata/content/body/value1`.
                    public var value1: Swift.String?
                    /// - Remark: Generated from `#/components/schemas/Body_Speech_to_Text_v1_speech_to_text_post/webhook_metadata/content/body/value2`.
                    public var value2: OpenAPIRuntime.OpenAPIObjectContainer?
                    /// Creates a new `bodyPayload`.
                    ///
                    /// - Parameters:
                    ///   - value1:
                    ///   - value2:
                    public init(
                        value1: Swift.String? = nil,
                        value2: OpenAPIRuntime.OpenAPIObjectContainer? = nil
                    ) {
                        self.value1 = value1
                        self.value2 = value2
                    }
                    public init(from decoder: any Decoder) throws {
                        var errors: [any Error] = []
                        do {
                            self.value1 = try decoder.decodeFromSingleValueContainer()
                        } catch {
                            errors.append(error)
                        }
                        do {
                            self.value2 = try .init(from: decoder)
                        } catch {
                            errors.append(error)
                        }
                        try Swift.DecodingError.verifyAtLeastOneSchemaIsNotNil(
                            [
                                self.value1,
                                self.value2
                            ],
                            type: Self.self,
                            codingPath: decoder.codingPath,
                            errors: errors
                        )
                    }
                    public func encode(to encoder: any Encoder) throws {
                        try encoder.encodeFirstNonNilValueToSingleValueContainer([
                            self.value1
                        ])
                        try self.value2?.encode(to: encoder)
                    }
                }
                public var body: Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.webhook_metadataPayload.bodyPayload
                /// Creates a new `webhook_metadataPayload`.
                ///
                /// - Parameters:
                ///   - body:
                public init(body: Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.webhook_metadataPayload.bodyPayload) {
                    self.body = body
                }
            }
            case webhook_metadata(OpenAPIRuntime.MultipartPart<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post.webhook_metadataPayload>)
            case undocumented(OpenAPIRuntime.MultipartRawPart)
        }
        /// - Remark: Generated from `#/components/schemas/DocxExportOptions`.
        public struct DocxExportOptions: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/DocxExportOptions/include_speakers`.
            public var include_speakers: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/DocxExportOptions/include_timestamps`.
            public var include_timestamps: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/DocxExportOptions/format`.
            @frozen public enum formatPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case docx = "docx"
            }
            /// - Remark: Generated from `#/components/schemas/DocxExportOptions/format`.
            public var format: Components.Schemas.DocxExportOptions.formatPayload
            /// - Remark: Generated from `#/components/schemas/DocxExportOptions/segment_on_silence_longer_than_s`.
            public var segment_on_silence_longer_than_s: Swift.Double?
            /// - Remark: Generated from `#/components/schemas/DocxExportOptions/max_segment_duration_s`.
            public var max_segment_duration_s: Swift.Double?
            /// - Remark: Generated from `#/components/schemas/DocxExportOptions/max_segment_chars`.
            public var max_segment_chars: Swift.Int?
            /// Creates a new `DocxExportOptions`.
            ///
            /// - Parameters:
            ///   - include_speakers:
            ///   - include_timestamps:
            ///   - format:
            ///   - segment_on_silence_longer_than_s:
            ///   - max_segment_duration_s:
            ///   - max_segment_chars:
            public init(
                include_speakers: Swift.Bool? = nil,
                include_timestamps: Swift.Bool? = nil,
                format: Components.Schemas.DocxExportOptions.formatPayload,
                segment_on_silence_longer_than_s: Swift.Double? = nil,
                max_segment_duration_s: Swift.Double? = nil,
                max_segment_chars: Swift.Int? = nil
            ) {
                self.include_speakers = include_speakers
                self.include_timestamps = include_timestamps
                self.format = format
                self.segment_on_silence_longer_than_s = segment_on_silence_longer_than_s
                self.max_segment_duration_s = max_segment_duration_s
                self.max_segment_chars = max_segment_chars
            }
            public enum CodingKeys: String, CodingKey {
                case include_speakers
                case include_timestamps
                case format
                case segment_on_silence_longer_than_s
                case max_segment_duration_s
                case max_segment_chars
            }
        }
        /// - Remark: Generated from `#/components/schemas/ExportOptions`.
        @frozen public enum ExportOptions: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/ExportOptions/DocxExportOptions`.
            case docx(Components.Schemas.DocxExportOptions)
            /// - Remark: Generated from `#/components/schemas/ExportOptions/HtmlExportOptions`.
            case html(Components.Schemas.HtmlExportOptions)
            /// - Remark: Generated from `#/components/schemas/ExportOptions/PdfExportOptions`.
            case pdf(Components.Schemas.PdfExportOptions)
            /// - Remark: Generated from `#/components/schemas/ExportOptions/SegmentedJsonExportOptions`.
            case segmented_json(Components.Schemas.SegmentedJsonExportOptions)
            /// - Remark: Generated from `#/components/schemas/ExportOptions/SrtExportOptions`.
            case srt(Components.Schemas.SrtExportOptions)
            /// - Remark: Generated from `#/components/schemas/ExportOptions/TxtExportOptions`.
            case txt(Components.Schemas.TxtExportOptions)
            public enum CodingKeys: String, CodingKey {
                case format
            }
            public init(from decoder: any Decoder) throws {
                let container = try decoder.container(keyedBy: CodingKeys.self)
                let discriminator = try container.decode(
                    Swift.String.self,
                    forKey: .format
                )
                switch discriminator {
                case "docx":
                    self = .docx(try .init(from: decoder))
                case "html":
                    self = .html(try .init(from: decoder))
                case "pdf":
                    self = .pdf(try .init(from: decoder))
                case "segmented_json":
                    self = .segmented_json(try .init(from: decoder))
                case "srt":
                    self = .srt(try .init(from: decoder))
                case "txt":
                    self = .txt(try .init(from: decoder))
                default:
                    throw Swift.DecodingError.unknownOneOfDiscriminator(
                        discriminatorKey: CodingKeys.format,
                        discriminatorValue: discriminator,
                        codingPath: decoder.codingPath
                    )
                }
            }
            public func encode(to encoder: any Encoder) throws {
                switch self {
                case let .docx(value):
                    try value.encode(to: encoder)
                case let .html(value):
                    try value.encode(to: encoder)
                case let .pdf(value):
                    try value.encode(to: encoder)
                case let .segmented_json(value):
                    try value.encode(to: encoder)
                case let .srt(value):
                    try value.encode(to: encoder)
                case let .txt(value):
                    try value.encode(to: encoder)
                }
            }
        }
        /// - Remark: Generated from `#/components/schemas/HTTPValidationError`.
        public struct HTTPValidationError: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/HTTPValidationError/detail`.
            public var detail: [Components.Schemas.ValidationError]?
            /// Creates a new `HTTPValidationError`.
            ///
            /// - Parameters:
            ///   - detail:
            public init(detail: [Components.Schemas.ValidationError]? = nil) {
                self.detail = detail
            }
            public enum CodingKeys: String, CodingKey {
                case detail
            }
        }
        /// - Remark: Generated from `#/components/schemas/HtmlExportOptions`.
        public struct HtmlExportOptions: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/HtmlExportOptions/include_speakers`.
            public var include_speakers: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/HtmlExportOptions/include_timestamps`.
            public var include_timestamps: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/HtmlExportOptions/format`.
            @frozen public enum formatPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case html = "html"
            }
            /// - Remark: Generated from `#/components/schemas/HtmlExportOptions/format`.
            public var format: Components.Schemas.HtmlExportOptions.formatPayload
            /// - Remark: Generated from `#/components/schemas/HtmlExportOptions/segment_on_silence_longer_than_s`.
            public var segment_on_silence_longer_than_s: Swift.Double?
            /// - Remark: Generated from `#/components/schemas/HtmlExportOptions/max_segment_duration_s`.
            public var max_segment_duration_s: Swift.Double?
            /// - Remark: Generated from `#/components/schemas/HtmlExportOptions/max_segment_chars`.
            public var max_segment_chars: Swift.Int?
            /// Creates a new `HtmlExportOptions`.
            ///
            /// - Parameters:
            ///   - include_speakers:
            ///   - include_timestamps:
            ///   - format:
            ///   - segment_on_silence_longer_than_s:
            ///   - max_segment_duration_s:
            ///   - max_segment_chars:
            public init(
                include_speakers: Swift.Bool? = nil,
                include_timestamps: Swift.Bool? = nil,
                format: Components.Schemas.HtmlExportOptions.formatPayload,
                segment_on_silence_longer_than_s: Swift.Double? = nil,
                max_segment_duration_s: Swift.Double? = nil,
                max_segment_chars: Swift.Int? = nil
            ) {
                self.include_speakers = include_speakers
                self.include_timestamps = include_timestamps
                self.format = format
                self.segment_on_silence_longer_than_s = segment_on_silence_longer_than_s
                self.max_segment_duration_s = max_segment_duration_s
                self.max_segment_chars = max_segment_chars
            }
            public enum CodingKeys: String, CodingKey {
                case include_speakers
                case include_timestamps
                case format
                case segment_on_silence_longer_than_s
                case max_segment_duration_s
                case max_segment_chars
            }
        }
        /// Response model for multichannel speech-to-text transcription.
        ///
        /// - Remark: Generated from `#/components/schemas/MultichannelSpeechToTextResponseModel`.
        public struct MultichannelSpeechToTextResponseModel: Codable, Hashable, Sendable {
            /// List of transcripts, one for each audio channel. Each transcript contains the text and word-level details for its respective channel.
            ///
            /// - Remark: Generated from `#/components/schemas/MultichannelSpeechToTextResponseModel/transcripts`.
            public var transcripts: [Components.Schemas.SpeechToTextChunkResponseModel]
            /// Creates a new `MultichannelSpeechToTextResponseModel`.
            ///
            /// - Parameters:
            ///   - transcripts: List of transcripts, one for each audio channel. Each transcript contains the text and word-level details for its respective channel.
            public init(transcripts: [Components.Schemas.SpeechToTextChunkResponseModel]) {
                self.transcripts = transcripts
            }
            public enum CodingKeys: String, CodingKey {
                case transcripts
            }
        }
        /// - Remark: Generated from `#/components/schemas/PdfExportOptions`.
        public struct PdfExportOptions: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/PdfExportOptions/include_speakers`.
            public var include_speakers: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/PdfExportOptions/include_timestamps`.
            public var include_timestamps: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/PdfExportOptions/format`.
            @frozen public enum formatPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case pdf = "pdf"
            }
            /// - Remark: Generated from `#/components/schemas/PdfExportOptions/format`.
            public var format: Components.Schemas.PdfExportOptions.formatPayload
            /// - Remark: Generated from `#/components/schemas/PdfExportOptions/segment_on_silence_longer_than_s`.
            public var segment_on_silence_longer_than_s: Swift.Double?
            /// - Remark: Generated from `#/components/schemas/PdfExportOptions/max_segment_duration_s`.
            public var max_segment_duration_s: Swift.Double?
            /// - Remark: Generated from `#/components/schemas/PdfExportOptions/max_segment_chars`.
            public var max_segment_chars: Swift.Int?
            /// Creates a new `PdfExportOptions`.
            ///
            /// - Parameters:
            ///   - include_speakers:
            ///   - include_timestamps:
            ///   - format:
            ///   - segment_on_silence_longer_than_s:
            ///   - max_segment_duration_s:
            ///   - max_segment_chars:
            public init(
                include_speakers: Swift.Bool? = nil,
                include_timestamps: Swift.Bool? = nil,
                format: Components.Schemas.PdfExportOptions.formatPayload,
                segment_on_silence_longer_than_s: Swift.Double? = nil,
                max_segment_duration_s: Swift.Double? = nil,
                max_segment_chars: Swift.Int? = nil
            ) {
                self.include_speakers = include_speakers
                self.include_timestamps = include_timestamps
                self.format = format
                self.segment_on_silence_longer_than_s = segment_on_silence_longer_than_s
                self.max_segment_duration_s = max_segment_duration_s
                self.max_segment_chars = max_segment_chars
            }
            public enum CodingKeys: String, CodingKey {
                case include_speakers
                case include_timestamps
                case format
                case segment_on_silence_longer_than_s
                case max_segment_duration_s
                case max_segment_chars
            }
        }
        /// - Remark: Generated from `#/components/schemas/SegmentedJsonExportOptions`.
        public struct SegmentedJsonExportOptions: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/SegmentedJsonExportOptions/include_speakers`.
            public var include_speakers: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/SegmentedJsonExportOptions/include_timestamps`.
            public var include_timestamps: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/SegmentedJsonExportOptions/format`.
            @frozen public enum formatPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case segmented_json = "segmented_json"
            }
            /// - Remark: Generated from `#/components/schemas/SegmentedJsonExportOptions/format`.
            public var format: Components.Schemas.SegmentedJsonExportOptions.formatPayload
            /// - Remark: Generated from `#/components/schemas/SegmentedJsonExportOptions/segment_on_silence_longer_than_s`.
            public var segment_on_silence_longer_than_s: Swift.Double?
            /// - Remark: Generated from `#/components/schemas/SegmentedJsonExportOptions/max_segment_duration_s`.
            public var max_segment_duration_s: Swift.Double?
            /// - Remark: Generated from `#/components/schemas/SegmentedJsonExportOptions/max_segment_chars`.
            public var max_segment_chars: Swift.Int?
            /// Creates a new `SegmentedJsonExportOptions`.
            ///
            /// - Parameters:
            ///   - include_speakers:
            ///   - include_timestamps:
            ///   - format:
            ///   - segment_on_silence_longer_than_s:
            ///   - max_segment_duration_s:
            ///   - max_segment_chars:
            public init(
                include_speakers: Swift.Bool? = nil,
                include_timestamps: Swift.Bool? = nil,
                format: Components.Schemas.SegmentedJsonExportOptions.formatPayload,
                segment_on_silence_longer_than_s: Swift.Double? = nil,
                max_segment_duration_s: Swift.Double? = nil,
                max_segment_chars: Swift.Int? = nil
            ) {
                self.include_speakers = include_speakers
                self.include_timestamps = include_timestamps
                self.format = format
                self.segment_on_silence_longer_than_s = segment_on_silence_longer_than_s
                self.max_segment_duration_s = max_segment_duration_s
                self.max_segment_chars = max_segment_chars
            }
            public enum CodingKeys: String, CodingKey {
                case include_speakers
                case include_timestamps
                case format
                case segment_on_silence_longer_than_s
                case max_segment_duration_s
                case max_segment_chars
            }
        }
        /// - Remark: Generated from `#/components/schemas/SpeechToTextCharacterResponseModel`.
        public struct SpeechToTextCharacterResponseModel: Codable, Hashable, Sendable {
            /// The character that was transcribed.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextCharacterResponseModel/text`.
            public var text: Swift.String
            /// The start time of the character in seconds.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextCharacterResponseModel/start`.
            public var start: Swift.Double?
            /// The end time of the character in seconds.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextCharacterResponseModel/end`.
            public var end: Swift.Double?
            /// Creates a new `SpeechToTextCharacterResponseModel`.
            ///
            /// - Parameters:
            ///   - text: The character that was transcribed.
            ///   - start: The start time of the character in seconds.
            ///   - end: The end time of the character in seconds.
            public init(
                text: Swift.String,
                start: Swift.Double? = nil,
                end: Swift.Double? = nil
            ) {
                self.text = text
                self.start = start
                self.end = end
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case start
                case end
            }
        }
        /// Chunk-level detail of the transcription with timing information.
        ///
        /// - Remark: Generated from `#/components/schemas/SpeechToTextChunkResponseModel`.
        public struct SpeechToTextChunkResponseModel: Codable, Hashable, Sendable {
            /// The detected language code (e.g. 'eng' for English).
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextChunkResponseModel/language_code`.
            public var language_code: Swift.String
            /// The confidence score of the language detection (0 to 1).
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextChunkResponseModel/language_probability`.
            public var language_probability: Swift.Double
            /// The raw text of the transcription.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextChunkResponseModel/text`.
            public var text: Swift.String
            /// List of words with their timing information.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextChunkResponseModel/words`.
            public var words: [Components.Schemas.SpeechToTextWordResponseModel]
            /// The channel index this transcript belongs to (for multichannel audio).
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextChunkResponseModel/channel_index`.
            public var channel_index: Swift.Int?
            /// Creates a new `SpeechToTextChunkResponseModel`.
            ///
            /// - Parameters:
            ///   - language_code: The detected language code (e.g. 'eng' for English).
            ///   - language_probability: The confidence score of the language detection (0 to 1).
            ///   - text: The raw text of the transcription.
            ///   - words: List of words with their timing information.
            ///   - channel_index: The channel index this transcript belongs to (for multichannel audio).
            public init(
                language_code: Swift.String,
                language_probability: Swift.Double,
                text: Swift.String,
                words: [Components.Schemas.SpeechToTextWordResponseModel],
                channel_index: Swift.Int? = nil
            ) {
                self.language_code = language_code
                self.language_probability = language_probability
                self.text = text
                self.words = words
                self.channel_index = channel_index
            }
            public enum CodingKeys: String, CodingKey {
                case language_code
                case language_probability
                case text
                case words
                case channel_index
            }
        }
        /// - Remark: Generated from `#/components/schemas/SpeechToTextWebhookResponseModel`.
        public struct SpeechToTextWebhookResponseModel: Codable, Hashable, Sendable {
            /// The message of the webhook response.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextWebhookResponseModel/message`.
            public var message: Swift.String
            /// The request ID of the webhook response.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextWebhookResponseModel/request_id`.
            public var request_id: Swift.String
            /// Creates a new `SpeechToTextWebhookResponseModel`.
            ///
            /// - Parameters:
            ///   - message: The message of the webhook response.
            ///   - request_id: The request ID of the webhook response.
            public init(
                message: Swift.String,
                request_id: Swift.String
            ) {
                self.message = message
                self.request_id = request_id
            }
            public enum CodingKeys: String, CodingKey {
                case message
                case request_id
            }
        }
        /// Word-level detail of the transcription with timing information.
        ///
        /// - Remark: Generated from `#/components/schemas/SpeechToTextWordResponseModel`.
        public struct SpeechToTextWordResponseModel: Codable, Hashable, Sendable {
            /// The word or sound that was transcribed.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextWordResponseModel/text`.
            public var text: Swift.String
            /// The type of the word or sound. 'audio_event' is used for non-word sounds like laughter or footsteps.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextWordResponseModel/type`.
            @frozen public enum _typePayload: String, Codable, Hashable, Sendable, CaseIterable {
                case word = "word"
                case spacing = "spacing"
                case audio_event = "audio_event"
            }
            /// The type of the word or sound. 'audio_event' is used for non-word sounds like laughter or footsteps.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextWordResponseModel/type`.
            public var _type: Components.Schemas.SpeechToTextWordResponseModel._typePayload
            /// The log of the probability with which this word was predicted. Logprobs are in range [-infinity, 0], higher logprobs indicate a higher confidence the model has in its predictions.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextWordResponseModel/logprob`.
            public var logprob: Swift.Double
            /// The start time of the word or sound in seconds.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextWordResponseModel/start`.
            public var start: Swift.Double?
            /// The end time of the word or sound in seconds.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextWordResponseModel/end`.
            public var end: Swift.Double?
            /// Unique identifier for the speaker of this word.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextWordResponseModel/speaker_id`.
            public var speaker_id: Swift.String?
            /// The characters that make up the word and their timing information.
            ///
            /// - Remark: Generated from `#/components/schemas/SpeechToTextWordResponseModel/characters`.
            public var characters: [Components.Schemas.SpeechToTextCharacterResponseModel]?
            /// Creates a new `SpeechToTextWordResponseModel`.
            ///
            /// - Parameters:
            ///   - text: The word or sound that was transcribed.
            ///   - _type: The type of the word or sound. 'audio_event' is used for non-word sounds like laughter or footsteps.
            ///   - logprob: The log of the probability with which this word was predicted. Logprobs are in range [-infinity, 0], higher logprobs indicate a higher confidence the model has in its predictions.
            ///   - start: The start time of the word or sound in seconds.
            ///   - end: The end time of the word or sound in seconds.
            ///   - speaker_id: Unique identifier for the speaker of this word.
            ///   - characters: The characters that make up the word and their timing information.
            public init(
                text: Swift.String,
                _type: Components.Schemas.SpeechToTextWordResponseModel._typePayload,
                logprob: Swift.Double,
                start: Swift.Double? = nil,
                end: Swift.Double? = nil,
                speaker_id: Swift.String? = nil,
                characters: [Components.Schemas.SpeechToTextCharacterResponseModel]? = nil
            ) {
                self.text = text
                self._type = _type
                self.logprob = logprob
                self.start = start
                self.end = end
                self.speaker_id = speaker_id
                self.characters = characters
            }
            public enum CodingKeys: String, CodingKey {
                case text
                case _type = "type"
                case logprob
                case start
                case end
                case speaker_id
                case characters
            }
        }
        /// - Remark: Generated from `#/components/schemas/SrtExportOptions`.
        public struct SrtExportOptions: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/SrtExportOptions/include_speakers`.
            public var include_speakers: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/SrtExportOptions/include_timestamps`.
            public var include_timestamps: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/SrtExportOptions/format`.
            @frozen public enum formatPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case srt = "srt"
            }
            /// - Remark: Generated from `#/components/schemas/SrtExportOptions/format`.
            public var format: Components.Schemas.SrtExportOptions.formatPayload
            /// - Remark: Generated from `#/components/schemas/SrtExportOptions/max_characters_per_line`.
            public var max_characters_per_line: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/SrtExportOptions/segment_on_silence_longer_than_s`.
            public var segment_on_silence_longer_than_s: Swift.Double?
            /// - Remark: Generated from `#/components/schemas/SrtExportOptions/max_segment_duration_s`.
            public var max_segment_duration_s: Swift.Double?
            /// - Remark: Generated from `#/components/schemas/SrtExportOptions/max_segment_chars`.
            public var max_segment_chars: Swift.Int?
            /// Creates a new `SrtExportOptions`.
            ///
            /// - Parameters:
            ///   - include_speakers:
            ///   - include_timestamps:
            ///   - format:
            ///   - max_characters_per_line:
            ///   - segment_on_silence_longer_than_s:
            ///   - max_segment_duration_s:
            ///   - max_segment_chars:
            public init(
                include_speakers: Swift.Bool? = nil,
                include_timestamps: Swift.Bool? = nil,
                format: Components.Schemas.SrtExportOptions.formatPayload,
                max_characters_per_line: Swift.Int? = nil,
                segment_on_silence_longer_than_s: Swift.Double? = nil,
                max_segment_duration_s: Swift.Double? = nil,
                max_segment_chars: Swift.Int? = nil
            ) {
                self.include_speakers = include_speakers
                self.include_timestamps = include_timestamps
                self.format = format
                self.max_characters_per_line = max_characters_per_line
                self.segment_on_silence_longer_than_s = segment_on_silence_longer_than_s
                self.max_segment_duration_s = max_segment_duration_s
                self.max_segment_chars = max_segment_chars
            }
            public enum CodingKeys: String, CodingKey {
                case include_speakers
                case include_timestamps
                case format
                case max_characters_per_line
                case segment_on_silence_longer_than_s
                case max_segment_duration_s
                case max_segment_chars
            }
        }
        /// - Remark: Generated from `#/components/schemas/TxtExportOptions`.
        public struct TxtExportOptions: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/TxtExportOptions/include_speakers`.
            public var include_speakers: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/TxtExportOptions/include_timestamps`.
            public var include_timestamps: Swift.Bool?
            /// - Remark: Generated from `#/components/schemas/TxtExportOptions/format`.
            @frozen public enum formatPayload: String, Codable, Hashable, Sendable, CaseIterable {
                case txt = "txt"
            }
            /// - Remark: Generated from `#/components/schemas/TxtExportOptions/format`.
            public var format: Components.Schemas.TxtExportOptions.formatPayload
            /// - Remark: Generated from `#/components/schemas/TxtExportOptions/max_characters_per_line`.
            public var max_characters_per_line: Swift.Int?
            /// - Remark: Generated from `#/components/schemas/TxtExportOptions/segment_on_silence_longer_than_s`.
            public var segment_on_silence_longer_than_s: Swift.Double?
            /// - Remark: Generated from `#/components/schemas/TxtExportOptions/max_segment_duration_s`.
            public var max_segment_duration_s: Swift.Double?
            /// - Remark: Generated from `#/components/schemas/TxtExportOptions/max_segment_chars`.
            public var max_segment_chars: Swift.Int?
            /// Creates a new `TxtExportOptions`.
            ///
            /// - Parameters:
            ///   - include_speakers:
            ///   - include_timestamps:
            ///   - format:
            ///   - max_characters_per_line:
            ///   - segment_on_silence_longer_than_s:
            ///   - max_segment_duration_s:
            ///   - max_segment_chars:
            public init(
                include_speakers: Swift.Bool? = nil,
                include_timestamps: Swift.Bool? = nil,
                format: Components.Schemas.TxtExportOptions.formatPayload,
                max_characters_per_line: Swift.Int? = nil,
                segment_on_silence_longer_than_s: Swift.Double? = nil,
                max_segment_duration_s: Swift.Double? = nil,
                max_segment_chars: Swift.Int? = nil
            ) {
                self.include_speakers = include_speakers
                self.include_timestamps = include_timestamps
                self.format = format
                self.max_characters_per_line = max_characters_per_line
                self.segment_on_silence_longer_than_s = segment_on_silence_longer_than_s
                self.max_segment_duration_s = max_segment_duration_s
                self.max_segment_chars = max_segment_chars
            }
            public enum CodingKeys: String, CodingKey {
                case include_speakers
                case include_timestamps
                case format
                case max_characters_per_line
                case segment_on_silence_longer_than_s
                case max_segment_duration_s
                case max_segment_chars
            }
        }
        /// - Remark: Generated from `#/components/schemas/ValidationError`.
        public struct ValidationError: Codable, Hashable, Sendable {
            /// - Remark: Generated from `#/components/schemas/ValidationError/locPayload`.
            public struct locPayloadPayload: Codable, Hashable, Sendable {
                /// - Remark: Generated from `#/components/schemas/ValidationError/locPayload/value1`.
                public var value1: Swift.String?
                /// - Remark: Generated from `#/components/schemas/ValidationError/locPayload/value2`.
                public var value2: Swift.Int?
                /// Creates a new `locPayloadPayload`.
                ///
                /// - Parameters:
                ///   - value1:
                ///   - value2:
                public init(
                    value1: Swift.String? = nil,
                    value2: Swift.Int? = nil
                ) {
                    self.value1 = value1
                    self.value2 = value2
                }
                public init(from decoder: any Decoder) throws {
                    var errors: [any Error] = []
                    do {
                        self.value1 = try decoder.decodeFromSingleValueContainer()
                    } catch {
                        errors.append(error)
                    }
                    do {
                        self.value2 = try decoder.decodeFromSingleValueContainer()
                    } catch {
                        errors.append(error)
                    }
                    try Swift.DecodingError.verifyAtLeastOneSchemaIsNotNil(
                        [
                            self.value1,
                            self.value2
                        ],
                        type: Self.self,
                        codingPath: decoder.codingPath,
                        errors: errors
                    )
                }
                public func encode(to encoder: any Encoder) throws {
                    try encoder.encodeFirstNonNilValueToSingleValueContainer([
                        self.value1,
                        self.value2
                    ])
                }
            }
            /// - Remark: Generated from `#/components/schemas/ValidationError/loc`.
            public typealias locPayload = [Components.Schemas.ValidationError.locPayloadPayload]
            /// - Remark: Generated from `#/components/schemas/ValidationError/loc`.
            public var loc: Components.Schemas.ValidationError.locPayload
            /// - Remark: Generated from `#/components/schemas/ValidationError/msg`.
            public var msg: Swift.String
            /// - Remark: Generated from `#/components/schemas/ValidationError/type`.
            public var _type: Swift.String
            /// Creates a new `ValidationError`.
            ///
            /// - Parameters:
            ///   - loc:
            ///   - msg:
            ///   - _type:
            public init(
                loc: Components.Schemas.ValidationError.locPayload,
                msg: Swift.String,
                _type: Swift.String
            ) {
                self.loc = loc
                self.msg = msg
                self._type = _type
            }
            public enum CodingKeys: String, CodingKey {
                case loc
                case msg
                case _type = "type"
            }
        }
    }
    /// Types generated from the `#/components/parameters` section of the OpenAPI document.
    public enum Parameters {}
    /// Types generated from the `#/components/requestBodies` section of the OpenAPI document.
    public enum RequestBodies {}
    /// Types generated from the `#/components/responses` section of the OpenAPI document.
    public enum Responses {}
    /// Types generated from the `#/components/headers` section of the OpenAPI document.
    public enum Headers {}
}

/// API operations, with input and output types, generated from `#/paths` in the OpenAPI document.
public enum Operations {
    /// Speech To Text
    ///
    /// Transcribe an audio or video file. If webhook is set to true, the request will be processed asynchronously and results sent to configured webhooks. When use_multi_channel is true and the provided audio has multiple channels, a 'transcripts' object with separate transcripts for each channel is returned. Otherwise, returns a single transcript. The optional webhook_metadata parameter allows you to attach custom data that will be included in webhook responses for request correlation and tracking.
    ///
    /// - Remark: HTTP `POST /v1/speech-to-text`.
    /// - Remark: Generated from `#/paths//v1/speech-to-text/post(Speech_to_Text_v1_speech_to_text_post)`.
    public enum Speech_to_Text_v1_speech_to_text_post {
        public static let id: Swift.String = "Speech_to_Text_v1_speech_to_text_post"
        public struct Input: Sendable, Hashable {
            /// - Remark: Generated from `#/paths/v1/speech-to-text/POST/query`.
            public struct Query: Sendable, Hashable {
                /// When enable_logging is set to false zero retention mode will be used for the request. This will mean history features are unavailable for this request, including request stitching. Zero retention mode may only be used by enterprise customers.
                ///
                /// - Remark: Generated from `#/paths/v1/speech-to-text/POST/query/enable_logging`.
                public var enable_logging: Swift.Bool?
                /// Creates a new `Query`.
                ///
                /// - Parameters:
                ///   - enable_logging: When enable_logging is set to false zero retention mode will be used for the request. This will mean history features are unavailable for this request, including request stitching. Zero retention mode may only be used by enterprise customers.
                public init(enable_logging: Swift.Bool? = nil) {
                    self.enable_logging = enable_logging
                }
            }
            public var query: Operations.Speech_to_Text_v1_speech_to_text_post.Input.Query
            /// - Remark: Generated from `#/paths/v1/speech-to-text/POST/header`.
            public struct Headers: Sendable, Hashable {
                public var accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Speech_to_Text_v1_speech_to_text_post.AcceptableContentType>]
                /// Creates a new `Headers`.
                ///
                /// - Parameters:
                ///   - accept:
                public init(accept: [OpenAPIRuntime.AcceptHeaderContentType<Operations.Speech_to_Text_v1_speech_to_text_post.AcceptableContentType>] = .defaultValues()) {
                    self.accept = accept
                }
            }
            public var headers: Operations.Speech_to_Text_v1_speech_to_text_post.Input.Headers
            /// - Remark: Generated from `#/paths/v1/speech-to-text/POST/requestBody`.
            @frozen public enum Body: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1/speech-to-text/POST/requestBody/content/multipart\/form-data`.
                case multipartForm(OpenAPIRuntime.MultipartBody<Components.Schemas.Body_Speech_to_Text_v1_speech_to_text_post>)
            }
            public var body: Operations.Speech_to_Text_v1_speech_to_text_post.Input.Body
            /// Creates a new `Input`.
            ///
            /// - Parameters:
            ///   - query:
            ///   - headers:
            ///   - body:
            public init(
                query: Operations.Speech_to_Text_v1_speech_to_text_post.Input.Query = .init(),
                headers: Operations.Speech_to_Text_v1_speech_to_text_post.Input.Headers = .init(),
                body: Operations.Speech_to_Text_v1_speech_to_text_post.Input.Body
            ) {
                self.query = query
                self.headers = headers
                self.body = body
            }
        }
        @frozen public enum Output: Sendable, Hashable {
            public struct Ok: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1/speech-to-text/POST/responses/200/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1/speech-to-text/POST/responses/200/content/json`.
                    public struct jsonPayload: Codable, Hashable, Sendable {
                        /// - Remark: Generated from `#/paths/v1/speech-to-text/POST/responses/200/content/json/value1`.
                        public var value1: Components.Schemas.SpeechToTextChunkResponseModel?
                        /// - Remark: Generated from `#/paths/v1/speech-to-text/POST/responses/200/content/json/value2`.
                        public var value2: Components.Schemas.MultichannelSpeechToTextResponseModel?
                        /// - Remark: Generated from `#/paths/v1/speech-to-text/POST/responses/200/content/json/value3`.
                        public var value3: Components.Schemas.SpeechToTextWebhookResponseModel?
                        /// Creates a new `jsonPayload`.
                        ///
                        /// - Parameters:
                        ///   - value1:
                        ///   - value2:
                        ///   - value3:
                        public init(
                            value1: Components.Schemas.SpeechToTextChunkResponseModel? = nil,
                            value2: Components.Schemas.MultichannelSpeechToTextResponseModel? = nil,
                            value3: Components.Schemas.SpeechToTextWebhookResponseModel? = nil
                        ) {
                            self.value1 = value1
                            self.value2 = value2
                            self.value3 = value3
                        }
                        public init(from decoder: any Decoder) throws {
                            var errors: [any Error] = []
                            do {
                                self.value1 = try .init(from: decoder)
                            } catch {
                                errors.append(error)
                            }
                            do {
                                self.value2 = try .init(from: decoder)
                            } catch {
                                errors.append(error)
                            }
                            do {
                                self.value3 = try .init(from: decoder)
                            } catch {
                                errors.append(error)
                            }
                            try Swift.DecodingError.verifyAtLeastOneSchemaIsNotNil(
                                [
                                    self.value1,
                                    self.value2,
                                    self.value3
                                ],
                                type: Self.self,
                                codingPath: decoder.codingPath,
                                errors: errors
                            )
                        }
                        public func encode(to encoder: any Encoder) throws {
                            try self.value1?.encode(to: encoder)
                            try self.value2?.encode(to: encoder)
                            try self.value3?.encode(to: encoder)
                        }
                    }
                    /// - Remark: Generated from `#/paths/v1/speech-to-text/POST/responses/200/content/application\/json`.
                    case json(Operations.Speech_to_Text_v1_speech_to_text_post.Output.Ok.Body.jsonPayload)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Operations.Speech_to_Text_v1_speech_to_text_post.Output.Ok.Body.jsonPayload {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Speech_to_Text_v1_speech_to_text_post.Output.Ok.Body
                /// Creates a new `Ok`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Speech_to_Text_v1_speech_to_text_post.Output.Ok.Body) {
                    self.body = body
                }
            }
            /// Synchronous transcription result
            ///
            /// - Remark: Generated from `#/paths//v1/speech-to-text/post(Speech_to_Text_v1_speech_to_text_post)/responses/200`.
            ///
            /// HTTP response code: `200 ok`.
            case ok(Operations.Speech_to_Text_v1_speech_to_text_post.Output.Ok)
            /// The associated value of the enum case if `self` is `.ok`.
            ///
            /// - Throws: An error if `self` is not `.ok`.
            /// - SeeAlso: `.ok`.
            public var ok: Operations.Speech_to_Text_v1_speech_to_text_post.Output.Ok {
                get throws {
                    switch self {
                    case let .ok(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "ok",
                            response: self
                        )
                    }
                }
            }
            public struct Accepted: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1/speech-to-text/POST/responses/202/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1/speech-to-text/POST/responses/202/content/application\/json`.
                    case json(OpenAPIRuntime.OpenAPIValueContainer)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: OpenAPIRuntime.OpenAPIValueContainer {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Speech_to_Text_v1_speech_to_text_post.Output.Accepted.Body
                /// Creates a new `Accepted`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Speech_to_Text_v1_speech_to_text_post.Output.Accepted.Body) {
                    self.body = body
                }
            }
            /// Asynchronous request accepted
            ///
            /// - Remark: Generated from `#/paths//v1/speech-to-text/post(Speech_to_Text_v1_speech_to_text_post)/responses/202`.
            ///
            /// HTTP response code: `202 accepted`.
            case accepted(Operations.Speech_to_Text_v1_speech_to_text_post.Output.Accepted)
            /// The associated value of the enum case if `self` is `.accepted`.
            ///
            /// - Throws: An error if `self` is not `.accepted`.
            /// - SeeAlso: `.accepted`.
            public var accepted: Operations.Speech_to_Text_v1_speech_to_text_post.Output.Accepted {
                get throws {
                    switch self {
                    case let .accepted(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "accepted",
                            response: self
                        )
                    }
                }
            }
            public struct UnprocessableContent: Sendable, Hashable {
                /// - Remark: Generated from `#/paths/v1/speech-to-text/POST/responses/422/content`.
                @frozen public enum Body: Sendable, Hashable {
                    /// - Remark: Generated from `#/paths/v1/speech-to-text/POST/responses/422/content/application\/json`.
                    case json(Components.Schemas.HTTPValidationError)
                    /// The associated value of the enum case if `self` is `.json`.
                    ///
                    /// - Throws: An error if `self` is not `.json`.
                    /// - SeeAlso: `.json`.
                    public var json: Components.Schemas.HTTPValidationError {
                        get throws {
                            switch self {
                            case let .json(body):
                                return body
                            }
                        }
                    }
                }
                /// Received HTTP response body
                public var body: Operations.Speech_to_Text_v1_speech_to_text_post.Output.UnprocessableContent.Body
                /// Creates a new `UnprocessableContent`.
                ///
                /// - Parameters:
                ///   - body: Received HTTP response body
                public init(body: Operations.Speech_to_Text_v1_speech_to_text_post.Output.UnprocessableContent.Body) {
                    self.body = body
                }
            }
            /// Validation Error
            ///
            /// - Remark: Generated from `#/paths//v1/speech-to-text/post(Speech_to_Text_v1_speech_to_text_post)/responses/422`.
            ///
            /// HTTP response code: `422 unprocessableContent`.
            case unprocessableContent(Operations.Speech_to_Text_v1_speech_to_text_post.Output.UnprocessableContent)
            /// The associated value of the enum case if `self` is `.unprocessableContent`.
            ///
            /// - Throws: An error if `self` is not `.unprocessableContent`.
            /// - SeeAlso: `.unprocessableContent`.
            public var unprocessableContent: Operations.Speech_to_Text_v1_speech_to_text_post.Output.UnprocessableContent {
                get throws {
                    switch self {
                    case let .unprocessableContent(response):
                        return response
                    default:
                        try throwUnexpectedResponseStatus(
                            expectedStatus: "unprocessableContent",
                            response: self
                        )
                    }
                }
            }
            /// Undocumented response.
            ///
            /// A response with a code that is not documented in the OpenAPI document.
            case undocumented(statusCode: Swift.Int, OpenAPIRuntime.UndocumentedPayload)
        }
        @frozen public enum AcceptableContentType: AcceptableProtocol {
            case json
            case other(Swift.String)
            public init?(rawValue: Swift.String) {
                switch rawValue.lowercased() {
                case "application/json":
                    self = .json
                default:
                    self = .other(rawValue)
                }
            }
            public var rawValue: Swift.String {
                switch self {
                case let .other(string):
                    return string
                case .json:
                    return "application/json"
                }
            }
            public static var allCases: [Self] {
                [
                    .json
                ]
            }
        }
    }
}
