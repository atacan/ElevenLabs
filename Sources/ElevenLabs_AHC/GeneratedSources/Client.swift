// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// This is the documentation for the ElevenLabs API. You can use this API to use our service programmatically, this is done by using your xi-api-key. <br/> You can view your xi-api-key using the 'Profile' tab on https://elevenlabs.io. Our API is experimental so all endpoints are subject to change.
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter {
        client.converter
    }
    /// Get Generated Items
    ///
    /// Returns metadata about all your generated audio.
    ///
    /// - Remark: HTTP `GET /v1/history`.
    /// - Remark: Generated from `#/paths//v1/history/get(Get_generated_items_v1_history_get)`.
    public func Get_generated_items_v1_history_get(_ input: Operations.Get_generated_items_v1_history_get.Input) async throws -> Operations.Get_generated_items_v1_history_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_generated_items_v1_history_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/history",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_size",
                    value: input.query.page_size
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start_after_history_item_id",
                    value: input.query.start_after_history_item_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "voice_id",
                    value: input.query.voice_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "search",
                    value: input.query.search
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "source",
                    value: input.query.source
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_generated_items_v1_history_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetSpeechHistoryResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_generated_items_v1_history_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get History Item By Id
    ///
    /// Returns information about an history item by its ID.
    ///
    /// - Remark: HTTP `GET /v1/history/{history_item_id}`.
    /// - Remark: Generated from `#/paths//v1/history/{history_item_id}/get(Get_history_item_by_ID_v1_history__history_item_id__get)`.
    public func Get_history_item_by_ID_v1_history__history_item_id__get(_ input: Operations.Get_history_item_by_ID_v1_history__history_item_id__get.Input) async throws -> Operations.Get_history_item_by_ID_v1_history__history_item_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_history_item_by_ID_v1_history__history_item_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/history/{}",
                    parameters: [
                        input.path.history_item_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_history_item_by_ID_v1_history__history_item_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SpeechHistoryItemResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_history_item_by_ID_v1_history__history_item_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete History Item
    ///
    /// Delete a history item by its ID
    ///
    /// - Remark: HTTP `DELETE /v1/history/{history_item_id}`.
    /// - Remark: Generated from `#/paths//v1/history/{history_item_id}/delete(Delete_history_item_v1_history__history_item_id__delete)`.
    public func Delete_history_item_v1_history__history_item_id__delete(_ input: Operations.Delete_history_item_v1_history__history_item_id__delete.Input) async throws -> Operations.Delete_history_item_v1_history__history_item_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_history_item_v1_history__history_item_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/history/{}",
                    parameters: [
                        input.path.history_item_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_history_item_v1_history__history_item_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_history_item_v1_history__history_item_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Audio From History Item
    ///
    /// Returns the audio of an history item.
    ///
    /// - Remark: HTTP `GET /v1/history/{history_item_id}/audio`.
    /// - Remark: Generated from `#/paths//v1/history/{history_item_id}/audio/get(Get_audio_from_history_item_v1_history__history_item_id__audio_get)`.
    public func Get_audio_from_history_item_v1_history__history_item_id__audio_get(_ input: Operations.Get_audio_from_history_item_v1_history__history_item_id__audio_get.Input) async throws -> Operations.Get_audio_from_history_item_v1_history__history_item_id__audio_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_audio_from_history_item_v1_history__history_item_id__audio_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/history/{}/audio",
                    parameters: [
                        input.path.history_item_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_audio_from_history_item_v1_history__history_item_id__audio_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "audio/mpeg"
                        ]
                    )
                    switch chosenContentType {
                    case "audio/mpeg":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .audio_mpeg(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_audio_from_history_item_v1_history__history_item_id__audio_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Download History Items
    ///
    /// Download one or more history items. If one history item ID is provided, we will return a single audio file. If more than one history item IDs are provided, we will provide the history items packed into a .zip file.
    ///
    /// - Remark: HTTP `POST /v1/history/download`.
    /// - Remark: Generated from `#/paths//v1/history/download/post(Download_history_items_v1_history_download_post)`.
    public func Download_history_items_v1_history_download_post(_ input: Operations.Download_history_items_v1_history_download_post.Input) async throws -> Operations.Download_history_items_v1_history_download_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Download_history_items_v1_history_download_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/history/download",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Download_history_items_v1_history_download_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Sound Generation
    ///
    /// Converts a text of your choice into sound
    ///
    /// - Remark: HTTP `POST /v1/sound-generation`.
    /// - Remark: Generated from `#/paths//v1/sound-generation/post(Sound_Generation_v1_sound_generation_post)`.
    public func Sound_Generation_v1_sound_generation_post(_ input: Operations.Sound_Generation_v1_sound_generation_post.Input) async throws -> Operations.Sound_Generation_v1_sound_generation_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Sound_Generation_v1_sound_generation_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/sound-generation",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Sound_Generation_v1_sound_generation_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "audio/mpeg"
                        ]
                    )
                    switch chosenContentType {
                    case "audio/mpeg":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .audio_mpeg(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Sound_Generation_v1_sound_generation_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Audio Isolation
    ///
    /// Removes background noise from audio
    ///
    /// - Remark: HTTP `POST /v1/audio-isolation`.
    /// - Remark: Generated from `#/paths//v1/audio-isolation/post(Audio_Isolation_v1_audio_isolation_post)`.
    public func Audio_Isolation_v1_audio_isolation_post(_ input: Operations.Audio_Isolation_v1_audio_isolation_post.Input) async throws -> Operations.Audio_Isolation_v1_audio_isolation_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Audio_Isolation_v1_audio_isolation_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/audio-isolation",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "audio"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .audio(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "audio",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Audio_Isolation_v1_audio_isolation_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "audio/mpeg"
                        ]
                    )
                    switch chosenContentType {
                    case "audio/mpeg":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .audio_mpeg(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Audio_Isolation_v1_audio_isolation_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Audio Isolation Stream
    ///
    /// Removes background noise from audio and streams the result
    ///
    /// - Remark: HTTP `POST /v1/audio-isolation/stream`.
    /// - Remark: Generated from `#/paths//v1/audio-isolation/stream/post(Audio_Isolation_Stream_v1_audio_isolation_stream_post)`.
    public func Audio_Isolation_Stream_v1_audio_isolation_stream_post(_ input: Operations.Audio_Isolation_Stream_v1_audio_isolation_stream_post.Input) async throws -> Operations.Audio_Isolation_Stream_v1_audio_isolation_stream_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Audio_Isolation_Stream_v1_audio_isolation_stream_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/audio-isolation/stream",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "audio"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .audio(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "audio",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Audio_Isolation_Stream_v1_audio_isolation_stream_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "audio/mpeg"
                        ]
                    )
                    switch chosenContentType {
                    case "audio/mpeg":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .audio_mpeg(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Audio_Isolation_Stream_v1_audio_isolation_stream_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Sample
    ///
    /// Removes a sample by its ID.
    ///
    /// - Remark: HTTP `DELETE /v1/voices/{voice_id}/samples/{sample_id}`.
    /// - Remark: Generated from `#/paths//v1/voices/{voice_id}/samples/{sample_id}/delete(Delete_sample_v1_voices__voice_id__samples__sample_id__delete)`.
    public func Delete_sample_v1_voices__voice_id__samples__sample_id__delete(_ input: Operations.Delete_sample_v1_voices__voice_id__samples__sample_id__delete.Input) async throws -> Operations.Delete_sample_v1_voices__voice_id__samples__sample_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_sample_v1_voices__voice_id__samples__sample_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/{}/samples/{}",
                    parameters: [
                        input.path.voice_id,
                        input.path.sample_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_sample_v1_voices__voice_id__samples__sample_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_sample_v1_voices__voice_id__samples__sample_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Audio From Sample
    ///
    /// Returns the audio corresponding to a sample attached to a voice.
    ///
    /// - Remark: HTTP `GET /v1/voices/{voice_id}/samples/{sample_id}/audio`.
    /// - Remark: Generated from `#/paths//v1/voices/{voice_id}/samples/{sample_id}/audio/get(Get_audio_from_sample_v1_voices__voice_id__samples__sample_id__audio_get)`.
    public func Get_audio_from_sample_v1_voices__voice_id__samples__sample_id__audio_get(_ input: Operations.Get_audio_from_sample_v1_voices__voice_id__samples__sample_id__audio_get.Input) async throws -> Operations.Get_audio_from_sample_v1_voices__voice_id__samples__sample_id__audio_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_audio_from_sample_v1_voices__voice_id__samples__sample_id__audio_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/{}/samples/{}/audio",
                    parameters: [
                        input.path.voice_id,
                        input.path.sample_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_audio_from_sample_v1_voices__voice_id__samples__sample_id__audio_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "audio/*"
                        ]
                    )
                    switch chosenContentType {
                    case "audio/*":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .audio__ast_(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_audio_from_sample_v1_voices__voice_id__samples__sample_id__audio_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Text To Speech
    ///
    /// Converts text into speech using a voice of your choice and returns audio.
    ///
    /// - Remark: HTTP `POST /v1/text-to-speech/{voice_id}`.
    /// - Remark: Generated from `#/paths//v1/text-to-speech/{voice_id}/post(Text_to_speech_v1_text_to_speech__voice_id__post)`.
    public func Text_to_speech_v1_text_to_speech__voice_id__post(_ input: Operations.Text_to_speech_v1_text_to_speech__voice_id__post.Input) async throws -> Operations.Text_to_speech_v1_text_to_speech__voice_id__post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Text_to_speech_v1_text_to_speech__voice_id__post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/text-to-speech/{}",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enable_logging",
                    value: input.query.enable_logging
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "optimize_streaming_latency",
                    value: input.query.optimize_streaming_latency
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "output_format",
                    value: input.query.output_format
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Text_to_speech_v1_text_to_speech__voice_id__post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "audio/mpeg"
                        ]
                    )
                    switch chosenContentType {
                    case "audio/mpeg":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .audio_mpeg(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Text_to_speech_v1_text_to_speech__voice_id__post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Text To Speech With Timestamps
    ///
    /// Converts text into speech using a voice of your choice and returns JSON containing audio as a base64 encoded string together with information on when which character was spoken.
    ///
    /// - Remark: HTTP `POST /v1/text-to-speech/{voice_id}/with-timestamps`.
    /// - Remark: Generated from `#/paths//v1/text-to-speech/{voice_id}/with-timestamps/post(Text_to_speech_with_timestamps_v1_text_to_speech__voice_id__with_timestamps_post)`.
    public func Text_to_speech_with_timestamps_v1_text_to_speech__voice_id__with_timestamps_post(_ input: Operations.Text_to_speech_with_timestamps_v1_text_to_speech__voice_id__with_timestamps_post.Input) async throws -> Operations.Text_to_speech_with_timestamps_v1_text_to_speech__voice_id__with_timestamps_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Text_to_speech_with_timestamps_v1_text_to_speech__voice_id__with_timestamps_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/text-to-speech/{}/with-timestamps",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enable_logging",
                    value: input.query.enable_logging
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "optimize_streaming_latency",
                    value: input.query.optimize_streaming_latency
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "output_format",
                    value: input.query.output_format
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Text_to_speech_with_timestamps_v1_text_to_speech__voice_id__with_timestamps_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Text_to_speech_with_timestamps_v1_text_to_speech__voice_id__with_timestamps_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Text To Speech Streaming
    ///
    /// Converts text into speech using a voice of your choice and returns audio as an audio stream.
    ///
    /// - Remark: HTTP `POST /v1/text-to-speech/{voice_id}/stream`.
    /// - Remark: Generated from `#/paths//v1/text-to-speech/{voice_id}/stream/post(Text_to_speech_streaming_v1_text_to_speech__voice_id__stream_post)`.
    public func Text_to_speech_streaming_v1_text_to_speech__voice_id__stream_post(_ input: Operations.Text_to_speech_streaming_v1_text_to_speech__voice_id__stream_post.Input) async throws -> Operations.Text_to_speech_streaming_v1_text_to_speech__voice_id__stream_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Text_to_speech_streaming_v1_text_to_speech__voice_id__stream_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/text-to-speech/{}/stream",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enable_logging",
                    value: input.query.enable_logging
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "optimize_streaming_latency",
                    value: input.query.optimize_streaming_latency
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "output_format",
                    value: input.query.output_format
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Text_to_speech_streaming_v1_text_to_speech__voice_id__stream_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Text To Speech Streaming With Timestamps
    ///
    /// Converts text into speech using a voice of your choice and returns a stream of JSONs containing audio as a base64 encoded string together with information on when which character was spoken.
    ///
    /// - Remark: HTTP `POST /v1/text-to-speech/{voice_id}/stream/with-timestamps`.
    /// - Remark: Generated from `#/paths//v1/text-to-speech/{voice_id}/stream/with-timestamps/post(Text_to_speech_streaming_with_timestamps_v1_text_to_speech__voice_id__stream_with_timestamps_post)`.
    public func Text_to_speech_streaming_with_timestamps_v1_text_to_speech__voice_id__stream_with_timestamps_post(_ input: Operations.Text_to_speech_streaming_with_timestamps_v1_text_to_speech__voice_id__stream_with_timestamps_post.Input) async throws -> Operations.Text_to_speech_streaming_with_timestamps_v1_text_to_speech__voice_id__stream_with_timestamps_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Text_to_speech_streaming_with_timestamps_v1_text_to_speech__voice_id__stream_with_timestamps_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/text-to-speech/{}/stream/with-timestamps",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enable_logging",
                    value: input.query.enable_logging
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "optimize_streaming_latency",
                    value: input.query.optimize_streaming_latency
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "output_format",
                    value: input.query.output_format
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Text_to_speech_streaming_with_timestamps_v1_text_to_speech__voice_id__stream_with_timestamps_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Speech To Speech
    ///
    /// Create speech by combining the content and emotion of the uploaded audio with a voice of your choice.
    ///
    /// - Remark: HTTP `POST /v1/speech-to-speech/{voice_id}`.
    /// - Remark: Generated from `#/paths//v1/speech-to-speech/{voice_id}/post(Speech_to_Speech_v1_speech_to_speech__voice_id__post)`.
    public func Speech_to_Speech_v1_speech_to_speech__voice_id__post(_ input: Operations.Speech_to_Speech_v1_speech_to_speech__voice_id__post.Input) async throws -> Operations.Speech_to_Speech_v1_speech_to_speech__voice_id__post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Speech_to_Speech_v1_speech_to_speech__voice_id__post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/speech-to-speech/{}",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enable_logging",
                    value: input.query.enable_logging
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "optimize_streaming_latency",
                    value: input.query.optimize_streaming_latency
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "output_format",
                    value: input.query.output_format
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "audio"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "model_id",
                            "remove_background_noise",
                            "seed",
                            "voice_settings"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .audio(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "audio",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .model_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "model_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .voice_settings(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "voice_settings",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .seed(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "seed",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .remove_background_noise(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "remove_background_noise",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Speech_to_Speech_v1_speech_to_speech__voice_id__post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "audio/mpeg"
                        ]
                    )
                    switch chosenContentType {
                    case "audio/mpeg":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .audio_mpeg(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Speech_to_Speech_v1_speech_to_speech__voice_id__post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Speech To Speech Streaming
    ///
    /// Create speech by combining the content and emotion of the uploaded audio with a voice of your choice and returns an audio stream.
    ///
    /// - Remark: HTTP `POST /v1/speech-to-speech/{voice_id}/stream`.
    /// - Remark: Generated from `#/paths//v1/speech-to-speech/{voice_id}/stream/post(Speech_to_Speech_Streaming_v1_speech_to_speech__voice_id__stream_post)`.
    public func Speech_to_Speech_Streaming_v1_speech_to_speech__voice_id__stream_post(_ input: Operations.Speech_to_Speech_Streaming_v1_speech_to_speech__voice_id__stream_post.Input) async throws -> Operations.Speech_to_Speech_Streaming_v1_speech_to_speech__voice_id__stream_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Speech_to_Speech_Streaming_v1_speech_to_speech__voice_id__stream_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/speech-to-speech/{}/stream",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "enable_logging",
                    value: input.query.enable_logging
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "optimize_streaming_latency",
                    value: input.query.optimize_streaming_latency
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "output_format",
                    value: input.query.output_format
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "audio"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "model_id",
                            "remove_background_noise",
                            "seed",
                            "voice_settings"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .audio(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "audio",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .model_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "model_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .voice_settings(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "voice_settings",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .seed(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "seed",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .remove_background_noise(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "remove_background_noise",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Speech_to_Speech_Streaming_v1_speech_to_speech__voice_id__stream_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Voice Generation Parameters
    ///
    /// Get possible parameters for the /v1/voice-generation/generate-voice endpoint.
    ///
    /// - Remark: HTTP `GET /v1/voice-generation/generate-voice/parameters`.
    /// - Remark: Generated from `#/paths//v1/voice-generation/generate-voice/parameters/get(Voice_Generation_Parameters_v1_voice_generation_generate_voice_parameters_get)`.
    public func Voice_Generation_Parameters_v1_voice_generation_generate_voice_parameters_get(_ input: Operations.Voice_Generation_Parameters_v1_voice_generation_generate_voice_parameters_get.Input) async throws -> Operations.Voice_Generation_Parameters_v1_voice_generation_generate_voice_parameters_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Voice_Generation_Parameters_v1_voice_generation_generate_voice_parameters_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voice-generation/generate-voice/parameters",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Voice_Generation_Parameters_v1_voice_generation_generate_voice_parameters_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.VoiceGenerationParameterResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Generate A Random Voice
    ///
    /// Generate a random voice based on parameters. This method returns a generated_voice_id in the response header, and a sample of the voice in the body. If you like the generated voice call /v1/voice-generation/create-voice with the generated_voice_id to create the voice.
    ///
    /// - Remark: HTTP `POST /v1/voice-generation/generate-voice`.
    /// - Remark: Generated from `#/paths//v1/voice-generation/generate-voice/post(Generate_a_random_voice_v1_voice_generation_generate_voice_post)`.
    public func Generate_a_random_voice_v1_voice_generation_generate_voice_post(_ input: Operations.Generate_a_random_voice_v1_voice_generation_generate_voice_post.Input) async throws -> Operations.Generate_a_random_voice_v1_voice_generation_generate_voice_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Generate_a_random_voice_v1_voice_generation_generate_voice_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voice-generation/generate-voice",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Generate_a_random_voice_v1_voice_generation_generate_voice_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "audio/mpeg"
                        ]
                    )
                    switch chosenContentType {
                    case "audio/mpeg":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .audio_mpeg(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Generate_a_random_voice_v1_voice_generation_generate_voice_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Generate A Voice Preview From Description
    ///
    /// Generate a custom voice based on voice description. This method returns a list of voice previews. Each preview has a generated_voice_id and a sample of the voice as base64 encoded mp3 audio. If you like the a voice previewand want to create the voice call /v1/text-to-voice/create-voice-from-preview with the generated_voice_id to create the voice.
    ///
    /// - Remark: HTTP `POST /v1/text-to-voice/create-previews`.
    /// - Remark: Generated from `#/paths//v1/text-to-voice/create-previews/post(Generate_a_voice_preview_from_description_v1_text_to_voice_create_previews_post)`.
    public func Generate_a_voice_preview_from_description_v1_text_to_voice_create_previews_post(_ input: Operations.Generate_a_voice_preview_from_description_v1_text_to_voice_create_previews_post.Input) async throws -> Operations.Generate_a_voice_preview_from_description_v1_text_to_voice_create_previews_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Generate_a_voice_preview_from_description_v1_text_to_voice_create_previews_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/text-to-voice/create-previews",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "output_format",
                    value: input.query.output_format
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Generate_a_voice_preview_from_description_v1_text_to_voice_create_previews_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.VoicePreviewsResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Generate_a_voice_preview_from_description_v1_text_to_voice_create_previews_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create A Previously Generated Voice
    ///
    /// Create a previously generated voice. This endpoint should be called after you fetched a generated_voice_id using /v1/voice-generation/generate-voice.
    ///
    /// - Remark: HTTP `POST /v1/voice-generation/create-voice`.
    /// - Remark: Generated from `#/paths//v1/voice-generation/create-voice/post(Create_a_previously_generated_voice_v1_voice_generation_create_voice_post)`.
    public func Create_a_previously_generated_voice_v1_voice_generation_create_voice_post(_ input: Operations.Create_a_previously_generated_voice_v1_voice_generation_create_voice_post.Input) async throws -> Operations.Create_a_previously_generated_voice_v1_voice_generation_create_voice_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Create_a_previously_generated_voice_v1_voice_generation_create_voice_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voice-generation/create-voice",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_a_previously_generated_voice_v1_voice_generation_create_voice_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.VoiceResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_a_previously_generated_voice_v1_voice_generation_create_voice_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create A New Voice From Voice Preview
    ///
    /// Create a voice from previously generated voice preview. This endpoint should be called after you fetched a generated_voice_id using /v1/text-to-voice/create-previews.
    ///
    /// - Remark: HTTP `POST /v1/text-to-voice/create-voice-from-preview`.
    /// - Remark: Generated from `#/paths//v1/text-to-voice/create-voice-from-preview/post(Create_a_new_voice_from_voice_preview_v1_text_to_voice_create_voice_from_preview_post)`.
    public func Create_a_new_voice_from_voice_preview_v1_text_to_voice_create_voice_from_preview_post(_ input: Operations.Create_a_new_voice_from_voice_preview_v1_text_to_voice_create_voice_from_preview_post.Input) async throws -> Operations.Create_a_new_voice_from_voice_preview_v1_text_to_voice_create_voice_from_preview_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Create_a_new_voice_from_voice_preview_v1_text_to_voice_create_voice_from_preview_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/text-to-voice/create-voice-from-preview",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_a_new_voice_from_voice_preview_v1_text_to_voice_create_voice_from_preview_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.VoiceResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_a_new_voice_from_voice_preview_v1_text_to_voice_create_voice_from_preview_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get User Subscription Info
    ///
    /// Gets extended information about the users subscription
    ///
    /// - Remark: HTTP `GET /v1/user/subscription`.
    /// - Remark: Generated from `#/paths//v1/user/subscription/get(Get_user_subscription_info_v1_user_subscription_get)`.
    public func Get_user_subscription_info_v1_user_subscription_get(_ input: Operations.Get_user_subscription_info_v1_user_subscription_get.Input) async throws -> Operations.Get_user_subscription_info_v1_user_subscription_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_user_subscription_info_v1_user_subscription_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/user/subscription",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_user_subscription_info_v1_user_subscription_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ExtendedSubscriptionResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_user_subscription_info_v1_user_subscription_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get User Info
    ///
    /// Gets information about the user
    ///
    /// - Remark: HTTP `GET /v1/user`.
    /// - Remark: Generated from `#/paths//v1/user/get(Get_user_info_v1_user_get)`.
    public func Get_user_info_v1_user_get(_ input: Operations.Get_user_info_v1_user_get.Input) async throws -> Operations.Get_user_info_v1_user_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_user_info_v1_user_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/user",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_user_info_v1_user_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UserResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_user_info_v1_user_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Voices
    ///
    /// Gets a list of all available voices for a user.
    ///
    /// - Remark: HTTP `GET /v1/voices`.
    /// - Remark: Generated from `#/paths//v1/voices/get(Get_voices_v1_voices_get)`.
    public func Get_voices_v1_voices_get(_ input: Operations.Get_voices_v1_voices_get.Input) async throws -> Operations.Get_voices_v1_voices_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_voices_v1_voices_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "show_legacy",
                    value: input.query.show_legacy
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voices_v1_voices_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetVoicesResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voices_v1_voices_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Default Voice Settings.
    ///
    /// Gets the default settings for voices. "similarity_boost" corresponds to"Clarity + Similarity Enhancement" in the web app and "stability" corresponds to "Stability" slider in the web app.
    ///
    /// - Remark: HTTP `GET /v1/voices/settings/default`.
    /// - Remark: Generated from `#/paths//v1/voices/settings/default/get(Get_default_voice_settings__v1_voices_settings_default_get)`.
    public func Get_default_voice_settings__v1_voices_settings_default_get(_ input: Operations.Get_default_voice_settings__v1_voices_settings_default_get.Input) async throws -> Operations.Get_default_voice_settings__v1_voices_settings_default_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_default_voice_settings__v1_voices_settings_default_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/settings/default",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_default_voice_settings__v1_voices_settings_default_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.VoiceSettingsResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Voice Settings
    ///
    /// Returns the settings for a specific voice. "similarity_boost" corresponds to"Clarity + Similarity Enhancement" in the web app and "stability" corresponds to "Stability" slider in the web app.
    ///
    /// - Remark: HTTP `GET /v1/voices/{voice_id}/settings`.
    /// - Remark: Generated from `#/paths//v1/voices/{voice_id}/settings/get(Get_voice_settings_v1_voices__voice_id__settings_get)`.
    public func Get_voice_settings_v1_voices__voice_id__settings_get(_ input: Operations.Get_voice_settings_v1_voices__voice_id__settings_get.Input) async throws -> Operations.Get_voice_settings_v1_voices__voice_id__settings_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_voice_settings_v1_voices__voice_id__settings_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/{}/settings",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voice_settings_v1_voices__voice_id__settings_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.VoiceSettingsResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voice_settings_v1_voices__voice_id__settings_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Voice
    ///
    /// Returns metadata about a specific voice.
    ///
    /// - Remark: HTTP `GET /v1/voices/{voice_id}`.
    /// - Remark: Generated from `#/paths//v1/voices/{voice_id}/get(Get_voice_v1_voices__voice_id__get)`.
    public func Get_voice_v1_voices__voice_id__get(_ input: Operations.Get_voice_v1_voices__voice_id__get.Input) async throws -> Operations.Get_voice_v1_voices__voice_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_voice_v1_voices__voice_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/{}",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "with_settings",
                    value: input.query.with_settings
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voice_v1_voices__voice_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.VoiceResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voice_v1_voices__voice_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Voice
    ///
    /// Deletes a voice by its ID.
    ///
    /// - Remark: HTTP `DELETE /v1/voices/{voice_id}`.
    /// - Remark: Generated from `#/paths//v1/voices/{voice_id}/delete(Delete_voice_v1_voices__voice_id__delete)`.
    public func Delete_voice_v1_voices__voice_id__delete(_ input: Operations.Delete_voice_v1_voices__voice_id__delete.Input) async throws -> Operations.Delete_voice_v1_voices__voice_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_voice_v1_voices__voice_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/{}",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_voice_v1_voices__voice_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_voice_v1_voices__voice_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Edit Voice Settings
    ///
    /// Edit your settings for a specific voice. "similarity_boost" corresponds to"Clarity + Similarity Enhancement" in the web app and "stability" corresponds to "Stability" slider in the web app.
    ///
    /// - Remark: HTTP `POST /v1/voices/{voice_id}/settings/edit`.
    /// - Remark: Generated from `#/paths//v1/voices/{voice_id}/settings/edit/post(Edit_voice_settings_v1_voices__voice_id__settings_edit_post)`.
    public func Edit_voice_settings_v1_voices__voice_id__settings_edit_post(_ input: Operations.Edit_voice_settings_v1_voices__voice_id__settings_edit_post.Input) async throws -> Operations.Edit_voice_settings_v1_voices__voice_id__settings_edit_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Edit_voice_settings_v1_voices__voice_id__settings_edit_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/{}/settings/edit",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Edit_voice_settings_v1_voices__voice_id__settings_edit_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Edit_voice_settings_v1_voices__voice_id__settings_edit_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add Voice
    ///
    /// Add a new voice to your collection of voices in VoiceLab.
    ///
    /// - Remark: HTTP `POST /v1/voices/add`.
    /// - Remark: Generated from `#/paths//v1/voices/add/post(Add_voice_v1_voices_add_post)`.
    public func Add_voice_v1_voices_add_post(_ input: Operations.Add_voice_v1_voices_add_post.Input) async throws -> Operations.Add_voice_v1_voices_add_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_voice_v1_voices_add_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/add",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "name"
                        ],
                        requiredAtLeastOncePartNames: [
                            "files"
                        ],
                        atMostOncePartNames: [
                            "description",
                            "labels",
                            "remove_background_noise"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .name(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "name",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .files(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "files",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .remove_background_noise(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "remove_background_noise",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .description(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "description",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .labels(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "labels",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_voice_v1_voices_add_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddVoiceIVCResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_voice_v1_voices_add_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Edit Voice
    ///
    /// Edit a voice created by you.
    ///
    /// - Remark: HTTP `POST /v1/voices/{voice_id}/edit`.
    /// - Remark: Generated from `#/paths//v1/voices/{voice_id}/edit/post(Edit_voice_v1_voices__voice_id__edit_post)`.
    public func Edit_voice_v1_voices__voice_id__edit_post(_ input: Operations.Edit_voice_v1_voices__voice_id__edit_post.Input) async throws -> Operations.Edit_voice_v1_voices__voice_id__edit_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Edit_voice_v1_voices__voice_id__edit_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/{}/edit",
                    parameters: [
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "name"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "description",
                            "labels",
                            "remove_background_noise"
                        ],
                        zeroOrMoreTimesPartNames: [
                            "files"
                        ],
                        encoding: { part in
                            switch part {
                            case let .name(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "name",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .files(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "files",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .remove_background_noise(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "remove_background_noise",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .description(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "description",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .labels(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "labels",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Edit_voice_v1_voices__voice_id__edit_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Edit_voice_v1_voices__voice_id__edit_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add Sharing Voice
    ///
    /// Add a sharing voice to your collection of voices in VoiceLab.
    ///
    /// - Remark: HTTP `POST /v1/voices/add/{public_user_id}/{voice_id}`.
    /// - Remark: Generated from `#/paths//v1/voices/add/{public_user_id}/{voice_id}/post(Add_sharing_voice_v1_voices_add__public_user_id___voice_id__post)`.
    public func Add_sharing_voice_v1_voices_add__public_user_id___voice_id__post(_ input: Operations.Add_sharing_voice_v1_voices_add__public_user_id___voice_id__post.Input) async throws -> Operations.Add_sharing_voice_v1_voices_add__public_user_id___voice_id__post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_sharing_voice_v1_voices_add__public_user_id___voice_id__post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/voices/add/{}/{}",
                    parameters: [
                        input.path.public_user_id,
                        input.path.voice_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_sharing_voice_v1_voices_add__public_user_id___voice_id__post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddVoiceResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_sharing_voice_v1_voices_add__public_user_id___voice_id__post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Podcast
    ///
    /// Create and auto-convert a podcast project. Currently, the LLM cost is covered by us but you will still be charged for the audio generation. In the future, you will be charged for both the LLM and audio generation costs.
    ///
    /// - Remark: HTTP `POST /v1/projects/podcast/create`.
    /// - Remark: Generated from `#/paths//v1/projects/podcast/create/post(Create_podcast_v1_projects_podcast_create_post)`.
    @available(*, deprecated)
    public func Create_podcast_v1_projects_podcast_create_post(_ input: Operations.Create_podcast_v1_projects_podcast_create_post.Input) async throws -> Operations.Create_podcast_v1_projects_podcast_create_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Create_podcast_v1_projects_podcast_create_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/podcast/create",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_podcast_v1_projects_podcast_create_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PodcastProjectResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_podcast_v1_projects_podcast_create_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// List Studio Projects
    ///
    /// Returns a list of your Studio projects with metadata.
    ///
    /// - Remark: HTTP `GET /v1/studio/projects`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/get(List_Studio_projects_v1_studio_projects_get)`.
    public func List_Studio_projects_v1_studio_projects_get(_ input: Operations.List_Studio_projects_v1_studio_projects_get.Input) async throws -> Operations.List_Studio_projects_v1_studio_projects_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.List_Studio_projects_v1_studio_projects_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.List_Studio_projects_v1_studio_projects_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetProjectsResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.List_Studio_projects_v1_studio_projects_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Studio Project
    ///
    /// Creates a new Studio project, it can be either initialized as blank, from a document or from a URL.
    ///
    /// - Remark: HTTP `POST /v1/studio/projects`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/post(Create_Studio_project_v1_studio_projects_post)`.
    public func Create_Studio_project_v1_studio_projects_post(_ input: Operations.Create_Studio_project_v1_studio_projects_post.Input) async throws -> Operations.Create_Studio_project_v1_studio_projects_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Create_Studio_project_v1_studio_projects_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "default_model_id",
                            "default_paragraph_voice_id",
                            "default_title_voice_id",
                            "name"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "acx_volume_normalization",
                            "apply_text_normalization",
                            "author",
                            "auto_assign_voices",
                            "auto_convert",
                            "callback_url",
                            "content_type",
                            "description",
                            "fiction",
                            "from_document",
                            "from_url",
                            "isbn_number",
                            "language",
                            "mature_content",
                            "original_publication_date",
                            "quality_check_on",
                            "quality_preset",
                            "target_audience",
                            "title",
                            "volume_normalization"
                        ],
                        zeroOrMoreTimesPartNames: [
                            "genres",
                            "pronunciation_dictionary_locators"
                        ],
                        encoding: { part in
                            switch part {
                            case let .name(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "name",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .default_title_voice_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "default_title_voice_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .default_paragraph_voice_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "default_paragraph_voice_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .default_model_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "default_model_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .from_url(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "from_url",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .from_document(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "from_document",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .quality_preset(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "quality_preset",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .title(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "title",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .author(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "author",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .description(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "description",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .genres(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "genres",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .target_audience(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "target_audience",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .language(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "language",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .content_type(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "content_type",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .original_publication_date(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "original_publication_date",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .mature_content(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "mature_content",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .isbn_number(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "isbn_number",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .acx_volume_normalization(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "acx_volume_normalization",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .volume_normalization(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "volume_normalization",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .pronunciation_dictionary_locators(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "pronunciation_dictionary_locators",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .callback_url(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "callback_url",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .fiction(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "fiction",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .quality_check_on(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "quality_check_on",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .apply_text_normalization(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "apply_text_normalization",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .auto_convert(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "auto_convert",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .auto_assign_voices(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "auto_assign_voices",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_Studio_project_v1_studio_projects_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddProjectResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_Studio_project_v1_studio_projects_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Projects
    ///
    /// Returns a list of your projects together and its metadata.
    ///
    /// - Remark: HTTP `GET /v1/projects`.
    /// - Remark: Generated from `#/paths//v1/projects/get(Get_projects_v1_projects_get)`.
    @available(*, deprecated)
    public func Get_projects_v1_projects_get(_ input: Operations.Get_projects_v1_projects_get.Input) async throws -> Operations.Get_projects_v1_projects_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_projects_v1_projects_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_projects_v1_projects_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetProjectsResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_projects_v1_projects_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add Project
    ///
    /// Creates a new project, it can be either initialized as blank, from a document or from a URL.
    ///
    /// - Remark: HTTP `POST /v1/projects/add`.
    /// - Remark: Generated from `#/paths//v1/projects/add/post(Add_project_v1_projects_add_post)`.
    @available(*, deprecated)
    public func Add_project_v1_projects_add_post(_ input: Operations.Add_project_v1_projects_add_post.Input) async throws -> Operations.Add_project_v1_projects_add_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_project_v1_projects_add_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/add",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "default_model_id",
                            "default_paragraph_voice_id",
                            "default_title_voice_id",
                            "name"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "acx_volume_normalization",
                            "apply_text_normalization",
                            "author",
                            "auto_assign_voices",
                            "auto_convert",
                            "callback_url",
                            "content_type",
                            "description",
                            "fiction",
                            "from_document",
                            "from_url",
                            "isbn_number",
                            "language",
                            "mature_content",
                            "original_publication_date",
                            "quality_check_on",
                            "quality_preset",
                            "target_audience",
                            "title",
                            "volume_normalization"
                        ],
                        zeroOrMoreTimesPartNames: [
                            "genres",
                            "pronunciation_dictionary_locators"
                        ],
                        encoding: { part in
                            switch part {
                            case let .name(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "name",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .default_title_voice_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "default_title_voice_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .default_paragraph_voice_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "default_paragraph_voice_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .default_model_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "default_model_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .from_url(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "from_url",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .from_document(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "from_document",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .quality_preset(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "quality_preset",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .title(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "title",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .author(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "author",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .description(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "description",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .genres(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "genres",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .target_audience(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "target_audience",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .language(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "language",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .content_type(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "content_type",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .original_publication_date(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "original_publication_date",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .mature_content(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "mature_content",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .isbn_number(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "isbn_number",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .acx_volume_normalization(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "acx_volume_normalization",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .volume_normalization(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "volume_normalization",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .pronunciation_dictionary_locators(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "pronunciation_dictionary_locators",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .callback_url(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "callback_url",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .fiction(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "fiction",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .quality_check_on(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "quality_check_on",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .apply_text_normalization(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "apply_text_normalization",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .auto_convert(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "auto_convert",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .auto_assign_voices(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "auto_assign_voices",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_project_v1_projects_add_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddProjectResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_project_v1_projects_add_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Studio Project
    ///
    /// Returns information about a specific Studio project. This endpoint returns more detailed information about a project than `GET /v1/studio`.
    ///
    /// - Remark: HTTP `GET /v1/studio/projects/{project_id}`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/get(Get_Studio_project_v1_studio_projects__project_id__get)`.
    public func Get_Studio_project_v1_studio_projects__project_id__get(_ input: Operations.Get_Studio_project_v1_studio_projects__project_id__get.Input) async throws -> Operations.Get_Studio_project_v1_studio_projects__project_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_Studio_project_v1_studio_projects__project_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Studio_project_v1_studio_projects__project_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProjectExtendedResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Studio_project_v1_studio_projects__project_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Studio Project Metadata
    ///
    /// Updates Studio project metadata.
    ///
    /// - Remark: HTTP `POST /v1/studio/projects/{project_id}`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/post(Update_Studio_project_metadata_v1_studio_projects__project_id__post)`.
    public func Update_Studio_project_metadata_v1_studio_projects__project_id__post(_ input: Operations.Update_Studio_project_metadata_v1_studio_projects__project_id__post.Input) async throws -> Operations.Update_Studio_project_metadata_v1_studio_projects__project_id__post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Update_Studio_project_metadata_v1_studio_projects__project_id__post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_Studio_project_metadata_v1_studio_projects__project_id__post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.EditProjectResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_Studio_project_metadata_v1_studio_projects__project_id__post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Studio Project
    ///
    /// Deletes a Studio project.
    ///
    /// - Remark: HTTP `DELETE /v1/studio/projects/{project_id}`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/delete(Delete_Studio_project_v1_studio_projects__project_id__delete)`.
    public func Delete_Studio_project_v1_studio_projects__project_id__delete(_ input: Operations.Delete_Studio_project_v1_studio_projects__project_id__delete.Input) async throws -> Operations.Delete_Studio_project_v1_studio_projects__project_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_Studio_project_v1_studio_projects__project_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_Studio_project_v1_studio_projects__project_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_Studio_project_v1_studio_projects__project_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Project By Id
    ///
    /// Returns information about a specific project. This endpoint returns more detailed information about a project than `GET /v1/projects`.
    ///
    /// - Remark: HTTP `GET /v1/projects/{project_id}`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/get(Get_project_by_ID_v1_projects__project_id__get)`.
    @available(*, deprecated)
    public func Get_project_by_ID_v1_projects__project_id__get(_ input: Operations.Get_project_by_ID_v1_projects__project_id__get.Input) async throws -> Operations.Get_project_by_ID_v1_projects__project_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_project_by_ID_v1_projects__project_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_project_by_ID_v1_projects__project_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProjectExtendedResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_project_by_ID_v1_projects__project_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Edit Basic Project Info
    ///
    /// Edits basic project info.
    ///
    /// - Remark: HTTP `POST /v1/projects/{project_id}`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/post(Edit_basic_project_info_v1_projects__project_id__post)`.
    @available(*, deprecated)
    public func Edit_basic_project_info_v1_projects__project_id__post(_ input: Operations.Edit_basic_project_info_v1_projects__project_id__post.Input) async throws -> Operations.Edit_basic_project_info_v1_projects__project_id__post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Edit_basic_project_info_v1_projects__project_id__post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Edit_basic_project_info_v1_projects__project_id__post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.EditProjectResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Edit_basic_project_info_v1_projects__project_id__post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Project
    ///
    /// Deletes a project.
    ///
    /// - Remark: HTTP `DELETE /v1/projects/{project_id}`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/delete(Delete_project_v1_projects__project_id__delete)`.
    @available(*, deprecated)
    public func Delete_project_v1_projects__project_id__delete(_ input: Operations.Delete_project_v1_projects__project_id__delete.Input) async throws -> Operations.Delete_project_v1_projects__project_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_project_v1_projects__project_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_project_v1_projects__project_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_project_v1_projects__project_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Studio Project Content
    ///
    /// Updates Studio project content.
    ///
    /// - Remark: HTTP `POST /v1/studio/projects/{project_id}/content`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/content/post(Update_Studio_project_content_v1_studio_projects__project_id__content_post)`.
    public func Update_Studio_project_content_v1_studio_projects__project_id__content_post(_ input: Operations.Update_Studio_project_content_v1_studio_projects__project_id__content_post.Input) async throws -> Operations.Update_Studio_project_content_v1_studio_projects__project_id__content_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Update_Studio_project_content_v1_studio_projects__project_id__content_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}/content",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_Studio_project_content_v1_studio_projects__project_id__content_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.EditProjectResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_Studio_project_content_v1_studio_projects__project_id__content_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Edit Project Content
    ///
    /// Edits project content.
    ///
    /// - Remark: HTTP `POST /v1/projects/{project_id}/content`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/content/post(Edit_project_content_v1_projects__project_id__content_post)`.
    @available(*, deprecated)
    public func Edit_project_content_v1_projects__project_id__content_post(_ input: Operations.Edit_project_content_v1_projects__project_id__content_post.Input) async throws -> Operations.Edit_project_content_v1_projects__project_id__content_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Edit_project_content_v1_projects__project_id__content_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/content",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Edit_project_content_v1_projects__project_id__content_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.EditProjectResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Edit_project_content_v1_projects__project_id__content_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Convert Studio Project
    ///
    /// Starts conversion of a Studio project and all of its chapters.
    ///
    /// - Remark: HTTP `POST /v1/studio/projects/{project_id}/convert`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/convert/post(Convert_Studio_project_v1_studio_projects__project_id__convert_post)`.
    public func Convert_Studio_project_v1_studio_projects__project_id__convert_post(_ input: Operations.Convert_Studio_project_v1_studio_projects__project_id__convert_post.Input) async throws -> Operations.Convert_Studio_project_v1_studio_projects__project_id__convert_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Convert_Studio_project_v1_studio_projects__project_id__convert_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}/convert",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Convert_Studio_project_v1_studio_projects__project_id__convert_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Convert_Studio_project_v1_studio_projects__project_id__convert_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Convert Project
    ///
    /// Starts conversion of a project and all of its chapters.
    ///
    /// - Remark: HTTP `POST /v1/projects/{project_id}/convert`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/convert/post(Convert_project_v1_projects__project_id__convert_post)`.
    @available(*, deprecated)
    public func Convert_project_v1_projects__project_id__convert_post(_ input: Operations.Convert_project_v1_projects__project_id__convert_post.Input) async throws -> Operations.Convert_project_v1_projects__project_id__convert_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Convert_project_v1_projects__project_id__convert_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/convert",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Convert_project_v1_projects__project_id__convert_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Convert_project_v1_projects__project_id__convert_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// List Studio Project Snapshots
    ///
    /// Gets the snapshots of a Studio project.
    ///
    /// - Remark: HTTP `GET /v1/studio/projects/{project_id}/snapshots`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/snapshots/get(List_Studio_project_snapshots_v1_studio_projects__project_id__snapshots_get)`.
    public func List_Studio_project_snapshots_v1_studio_projects__project_id__snapshots_get(_ input: Operations.List_Studio_project_snapshots_v1_studio_projects__project_id__snapshots_get.Input) async throws -> Operations.List_Studio_project_snapshots_v1_studio_projects__project_id__snapshots_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.List_Studio_project_snapshots_v1_studio_projects__project_id__snapshots_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}/snapshots",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.List_Studio_project_snapshots_v1_studio_projects__project_id__snapshots_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProjectSnapshotsResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.List_Studio_project_snapshots_v1_studio_projects__project_id__snapshots_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Project Snapshots
    ///
    /// Gets the snapshots of a project.
    ///
    /// - Remark: HTTP `GET /v1/projects/{project_id}/snapshots`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/snapshots/get(Get_project_snapshots_v1_projects__project_id__snapshots_get)`.
    @available(*, deprecated)
    public func Get_project_snapshots_v1_projects__project_id__snapshots_get(_ input: Operations.Get_project_snapshots_v1_projects__project_id__snapshots_get.Input) async throws -> Operations.Get_project_snapshots_v1_projects__project_id__snapshots_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_project_snapshots_v1_projects__project_id__snapshots_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/snapshots",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_project_snapshots_v1_projects__project_id__snapshots_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProjectSnapshotsResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_project_snapshots_v1_projects__project_id__snapshots_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stream Studio Project Audio
    ///
    /// Stream the audio from a Studio project snapshot.
    ///
    /// - Remark: HTTP `POST /v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}/stream`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}/stream/post(Stream_Studio_project_audio_v1_studio_projects__project_id__snapshots__project_snapshot_id__stream_post)`.
    public func Stream_Studio_project_audio_v1_studio_projects__project_id__snapshots__project_snapshot_id__stream_post(_ input: Operations.Stream_Studio_project_audio_v1_studio_projects__project_id__snapshots__project_snapshot_id__stream_post.Input) async throws -> Operations.Stream_Studio_project_audio_v1_studio_projects__project_id__snapshots__project_snapshot_id__stream_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Stream_Studio_project_audio_v1_studio_projects__project_id__snapshots__project_snapshot_id__stream_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}/snapshots/{}/stream",
                    parameters: [
                        input.path.project_id,
                        input.path.project_snapshot_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Stream_Studio_project_audio_v1_studio_projects__project_id__snapshots__project_snapshot_id__stream_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stream Project Audio
    ///
    /// Stream the audio from a project snapshot.
    ///
    /// - Remark: HTTP `POST /v1/projects/{project_id}/snapshots/{project_snapshot_id}/stream`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/snapshots/{project_snapshot_id}/stream/post(Stream_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__stream_post)`.
    @available(*, deprecated)
    public func Stream_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__stream_post(_ input: Operations.Stream_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__stream_post.Input) async throws -> Operations.Stream_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__stream_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Stream_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__stream_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/snapshots/{}/stream",
                    parameters: [
                        input.path.project_id,
                        input.path.project_snapshot_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Stream_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__stream_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Streams Archive With Studio Project Audio
    ///
    /// Returns a compressed archive of the Studio project's audio.
    ///
    /// - Remark: HTTP `POST /v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}/archive`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/snapshots/{project_snapshot_id}/archive/post(Streams_archive_with_Studio_project_audio_v1_studio_projects__project_id__snapshots__project_snapshot_id__archive_post)`.
    public func Streams_archive_with_Studio_project_audio_v1_studio_projects__project_id__snapshots__project_snapshot_id__archive_post(_ input: Operations.Streams_archive_with_Studio_project_audio_v1_studio_projects__project_id__snapshots__project_snapshot_id__archive_post.Input) async throws -> Operations.Streams_archive_with_Studio_project_audio_v1_studio_projects__project_id__snapshots__project_snapshot_id__archive_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Streams_archive_with_Studio_project_audio_v1_studio_projects__project_id__snapshots__project_snapshot_id__archive_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}/snapshots/{}/archive",
                    parameters: [
                        input.path.project_id,
                        input.path.project_snapshot_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Streams_archive_with_Studio_project_audio_v1_studio_projects__project_id__snapshots__project_snapshot_id__archive_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Streams Archive With Project Audio
    ///
    /// Streams archive with project audio.
    ///
    /// - Remark: HTTP `POST /v1/projects/{project_id}/snapshots/{project_snapshot_id}/archive`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/snapshots/{project_snapshot_id}/archive/post(Streams_archive_with_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__archive_post)`.
    @available(*, deprecated)
    public func Streams_archive_with_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__archive_post(_ input: Operations.Streams_archive_with_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__archive_post.Input) async throws -> Operations.Streams_archive_with_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__archive_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Streams_archive_with_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__archive_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/snapshots/{}/archive",
                    parameters: [
                        input.path.project_id,
                        input.path.project_snapshot_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Streams_archive_with_project_audio_v1_projects__project_id__snapshots__project_snapshot_id__archive_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// List Chapters
    ///
    /// Returns a list of a Studio project's chapters.
    ///
    /// - Remark: HTTP `GET /v1/studio/projects/{project_id}/chapters`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/chapters/get(List_chapters_v1_studio_projects__project_id__chapters_get)`.
    public func List_chapters_v1_studio_projects__project_id__chapters_get(_ input: Operations.List_chapters_v1_studio_projects__project_id__chapters_get.Input) async throws -> Operations.List_chapters_v1_studio_projects__project_id__chapters_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.List_chapters_v1_studio_projects__project_id__chapters_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}/chapters",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.List_chapters_v1_studio_projects__project_id__chapters_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetChaptersResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.List_chapters_v1_studio_projects__project_id__chapters_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Chapter
    ///
    /// Creates a new chapter either as blank or from a URL.
    ///
    /// - Remark: HTTP `POST /v1/studio/projects/{project_id}/chapters`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/chapters/post(Create_chapter_v1_studio_projects__project_id__chapters_post)`.
    public func Create_chapter_v1_studio_projects__project_id__chapters_post(_ input: Operations.Create_chapter_v1_studio_projects__project_id__chapters_post.Input) async throws -> Operations.Create_chapter_v1_studio_projects__project_id__chapters_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Create_chapter_v1_studio_projects__project_id__chapters_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}/chapters",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_chapter_v1_studio_projects__project_id__chapters_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddChapterResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_chapter_v1_studio_projects__project_id__chapters_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Chapters
    ///
    /// Returns a list of your chapters for a project together and its metadata.
    ///
    /// - Remark: HTTP `GET /v1/projects/{project_id}/chapters`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/chapters/get(Get_chapters_v1_projects__project_id__chapters_get)`.
    @available(*, deprecated)
    public func Get_chapters_v1_projects__project_id__chapters_get(_ input: Operations.Get_chapters_v1_projects__project_id__chapters_get.Input) async throws -> Operations.Get_chapters_v1_projects__project_id__chapters_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_chapters_v1_projects__project_id__chapters_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/chapters",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_chapters_v1_projects__project_id__chapters_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetChaptersResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_chapters_v1_projects__project_id__chapters_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Chapter
    ///
    /// Returns information about a specific chapter.
    ///
    /// - Remark: HTTP `GET /v1/studio/projects/{project_id}/chapters/{chapter_id}`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/chapters/{chapter_id}/get(Get_chapter_v1_studio_projects__project_id__chapters__chapter_id__get)`.
    public func Get_chapter_v1_studio_projects__project_id__chapters__chapter_id__get(_ input: Operations.Get_chapter_v1_studio_projects__project_id__chapters__chapter_id__get.Input) async throws -> Operations.Get_chapter_v1_studio_projects__project_id__chapters__chapter_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_chapter_v1_studio_projects__project_id__chapters__chapter_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}/chapters/{}",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_chapter_v1_studio_projects__project_id__chapters__chapter_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ChapterWithContentResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_chapter_v1_studio_projects__project_id__chapters__chapter_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Chapter
    ///
    /// Updates a chapter.
    ///
    /// - Remark: HTTP `POST /v1/studio/projects/{project_id}/chapters/{chapter_id}`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/chapters/{chapter_id}/post(Update_chapter_v1_studio_projects__project_id__chapters__chapter_id__post)`.
    public func Update_chapter_v1_studio_projects__project_id__chapters__chapter_id__post(_ input: Operations.Update_chapter_v1_studio_projects__project_id__chapters__chapter_id__post.Input) async throws -> Operations.Update_chapter_v1_studio_projects__project_id__chapters__chapter_id__post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Update_chapter_v1_studio_projects__project_id__chapters__chapter_id__post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}/chapters/{}",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_chapter_v1_studio_projects__project_id__chapters__chapter_id__post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.EditChapterResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_chapter_v1_studio_projects__project_id__chapters__chapter_id__post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Chapter
    ///
    /// Deletes a chapter.
    ///
    /// - Remark: HTTP `DELETE /v1/studio/projects/{project_id}/chapters/{chapter_id}`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/chapters/{chapter_id}/delete(Delete_chapter_v1_studio_projects__project_id__chapters__chapter_id__delete)`.
    public func Delete_chapter_v1_studio_projects__project_id__chapters__chapter_id__delete(_ input: Operations.Delete_chapter_v1_studio_projects__project_id__chapters__chapter_id__delete.Input) async throws -> Operations.Delete_chapter_v1_studio_projects__project_id__chapters__chapter_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_chapter_v1_studio_projects__project_id__chapters__chapter_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}/chapters/{}",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_chapter_v1_studio_projects__project_id__chapters__chapter_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_chapter_v1_studio_projects__project_id__chapters__chapter_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Chapter By Id
    ///
    /// Returns information about a specific chapter.
    ///
    /// - Remark: HTTP `GET /v1/projects/{project_id}/chapters/{chapter_id}`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/chapters/{chapter_id}/get(Get_chapter_by_ID_v1_projects__project_id__chapters__chapter_id__get)`.
    @available(*, deprecated)
    public func Get_chapter_by_ID_v1_projects__project_id__chapters__chapter_id__get(_ input: Operations.Get_chapter_by_ID_v1_projects__project_id__chapters__chapter_id__get.Input) async throws -> Operations.Get_chapter_by_ID_v1_projects__project_id__chapters__chapter_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_chapter_by_ID_v1_projects__project_id__chapters__chapter_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/chapters/{}",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_chapter_by_ID_v1_projects__project_id__chapters__chapter_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ChapterWithContentResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_chapter_by_ID_v1_projects__project_id__chapters__chapter_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Edit Chapter
    ///
    /// Edits a chapter.
    ///
    /// - Remark: HTTP `PATCH /v1/projects/{project_id}/chapters/{chapter_id}`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/chapters/{chapter_id}/patch(Edit_chapter_v1_projects__project_id__chapters__chapter_id__patch)`.
    @available(*, deprecated)
    public func Edit_chapter_v1_projects__project_id__chapters__chapter_id__patch(_ input: Operations.Edit_chapter_v1_projects__project_id__chapters__chapter_id__patch.Input) async throws -> Operations.Edit_chapter_v1_projects__project_id__chapters__chapter_id__patch.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Edit_chapter_v1_projects__project_id__chapters__chapter_id__patch.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/chapters/{}",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Edit_chapter_v1_projects__project_id__chapters__chapter_id__patch.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.EditChapterResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Edit_chapter_v1_projects__project_id__chapters__chapter_id__patch.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Chapter
    ///
    /// Deletes a chapter.
    ///
    /// - Remark: HTTP `DELETE /v1/projects/{project_id}/chapters/{chapter_id}`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/chapters/{chapter_id}/delete(Delete_chapter_v1_projects__project_id__chapters__chapter_id__delete)`.
    @available(*, deprecated)
    public func Delete_chapter_v1_projects__project_id__chapters__chapter_id__delete(_ input: Operations.Delete_chapter_v1_projects__project_id__chapters__chapter_id__delete.Input) async throws -> Operations.Delete_chapter_v1_projects__project_id__chapters__chapter_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_chapter_v1_projects__project_id__chapters__chapter_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/chapters/{}",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_chapter_v1_projects__project_id__chapters__chapter_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_chapter_v1_projects__project_id__chapters__chapter_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add Chapter To A Project
    ///
    /// Creates a new chapter either as blank or from a URL.
    ///
    /// - Remark: HTTP `POST /v1/projects/{project_id}/chapters/add`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/chapters/add/post(Add_chapter_to_a_project_v1_projects__project_id__chapters_add_post)`.
    @available(*, deprecated)
    public func Add_chapter_to_a_project_v1_projects__project_id__chapters_add_post(_ input: Operations.Add_chapter_to_a_project_v1_projects__project_id__chapters_add_post.Input) async throws -> Operations.Add_chapter_to_a_project_v1_projects__project_id__chapters_add_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_chapter_to_a_project_v1_projects__project_id__chapters_add_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/chapters/add",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_chapter_to_a_project_v1_projects__project_id__chapters_add_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddChapterResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_chapter_to_a_project_v1_projects__project_id__chapters_add_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Convert Chapter
    ///
    /// Starts conversion of a specific chapter.
    ///
    /// - Remark: HTTP `POST /v1/studio/projects/{project_id}/chapters/{chapter_id}/convert`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/chapters/{chapter_id}/convert/post(Convert_chapter_v1_studio_projects__project_id__chapters__chapter_id__convert_post)`.
    public func Convert_chapter_v1_studio_projects__project_id__chapters__chapter_id__convert_post(_ input: Operations.Convert_chapter_v1_studio_projects__project_id__chapters__chapter_id__convert_post.Input) async throws -> Operations.Convert_chapter_v1_studio_projects__project_id__chapters__chapter_id__convert_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Convert_chapter_v1_studio_projects__project_id__chapters__chapter_id__convert_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}/chapters/{}/convert",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Convert_chapter_v1_studio_projects__project_id__chapters__chapter_id__convert_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Convert_chapter_v1_studio_projects__project_id__chapters__chapter_id__convert_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Convert Chapter
    ///
    /// Starts conversion of a specific chapter.
    ///
    /// - Remark: HTTP `POST /v1/projects/{project_id}/chapters/{chapter_id}/convert`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/chapters/{chapter_id}/convert/post(Convert_chapter_v1_projects__project_id__chapters__chapter_id__convert_post)`.
    @available(*, deprecated)
    public func Convert_chapter_v1_projects__project_id__chapters__chapter_id__convert_post(_ input: Operations.Convert_chapter_v1_projects__project_id__chapters__chapter_id__convert_post.Input) async throws -> Operations.Convert_chapter_v1_projects__project_id__chapters__chapter_id__convert_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Convert_chapter_v1_projects__project_id__chapters__chapter_id__convert_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/chapters/{}/convert",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Convert_chapter_v1_projects__project_id__chapters__chapter_id__convert_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Convert_chapter_v1_projects__project_id__chapters__chapter_id__convert_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// List Chapter Snapshots
    ///
    /// Gets information about all the snapshots of a chapter, each snapshot corresponds can be downloaded as audio. Whenever a chapter is converted a snapshot will be automatically created.
    ///
    /// - Remark: HTTP `GET /v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots/get(List_chapter_snapshots_v1_studio_projects__project_id__chapters__chapter_id__snapshots_get)`.
    public func List_chapter_snapshots_v1_studio_projects__project_id__chapters__chapter_id__snapshots_get(_ input: Operations.List_chapter_snapshots_v1_studio_projects__project_id__chapters__chapter_id__snapshots_get.Input) async throws -> Operations.List_chapter_snapshots_v1_studio_projects__project_id__chapters__chapter_id__snapshots_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.List_chapter_snapshots_v1_studio_projects__project_id__chapters__chapter_id__snapshots_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}/chapters/{}/snapshots",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.List_chapter_snapshots_v1_studio_projects__project_id__chapters__chapter_id__snapshots_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ChapterSnapshotsResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.List_chapter_snapshots_v1_studio_projects__project_id__chapters__chapter_id__snapshots_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// List Chapter Snapshots
    ///
    /// Gets information about all the snapshots of a chapter, each snapshot corresponds can be downloaded as audio. Whenever a chapter is converted a snapshot will be automatically created.
    ///
    /// - Remark: HTTP `GET /v1/projects/{project_id}/chapters/{chapter_id}/snapshots`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/chapters/{chapter_id}/snapshots/get(List_chapter_snapshots_v1_projects__project_id__chapters__chapter_id__snapshots_get)`.
    @available(*, deprecated)
    public func List_chapter_snapshots_v1_projects__project_id__chapters__chapter_id__snapshots_get(_ input: Operations.List_chapter_snapshots_v1_projects__project_id__chapters__chapter_id__snapshots_get.Input) async throws -> Operations.List_chapter_snapshots_v1_projects__project_id__chapters__chapter_id__snapshots_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.List_chapter_snapshots_v1_projects__project_id__chapters__chapter_id__snapshots_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/chapters/{}/snapshots",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.List_chapter_snapshots_v1_projects__project_id__chapters__chapter_id__snapshots_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ChapterSnapshotsResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.List_chapter_snapshots_v1_projects__project_id__chapters__chapter_id__snapshots_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stream Chapter Audio
    ///
    /// Stream the audio from a chapter snapshot. Use `GET /v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots` to return the snapshots of a chapter.
    ///
    /// - Remark: HTTP `POST /v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots/{chapter_snapshot_id}/stream`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/chapters/{chapter_id}/snapshots/{chapter_snapshot_id}/stream/post(Stream_chapter_audio_v1_studio_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post)`.
    public func Stream_chapter_audio_v1_studio_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post(_ input: Operations.Stream_chapter_audio_v1_studio_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post.Input) async throws -> Operations.Stream_chapter_audio_v1_studio_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Stream_chapter_audio_v1_studio_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}/chapters/{}/snapshots/{}/stream",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id,
                        input.path.chapter_snapshot_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Stream_chapter_audio_v1_studio_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Stream Chapter Audio
    ///
    /// Stream the audio from a chapter snapshot. Use `GET /v1/projects/{project_id}/chapters/{chapter_id}/snapshots` to return the chapter snapshots of a chapter.
    ///
    /// - Remark: HTTP `POST /v1/projects/{project_id}/chapters/{chapter_id}/snapshots/{chapter_snapshot_id}/stream`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/chapters/{chapter_id}/snapshots/{chapter_snapshot_id}/stream/post(Stream_chapter_audio_v1_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post)`.
    @available(*, deprecated)
    public func Stream_chapter_audio_v1_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post(_ input: Operations.Stream_chapter_audio_v1_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post.Input) async throws -> Operations.Stream_chapter_audio_v1_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Stream_chapter_audio_v1_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/chapters/{}/snapshots/{}/stream",
                    parameters: [
                        input.path.project_id,
                        input.path.chapter_id,
                        input.path.chapter_snapshot_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Stream_chapter_audio_v1_projects__project_id__chapters__chapter_id__snapshots__chapter_snapshot_id__stream_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Pronunciation Dictionaries
    ///
    /// Create a set of pronunciation dictionaries acting on a project. This will automatically mark text within this project as requiring reconverting where the new dictionary would apply or the old one no longer does.
    ///
    /// - Remark: HTTP `POST /v1/studio/projects/{project_id}/pronunciation-dictionaries`.
    /// - Remark: Generated from `#/paths//v1/studio/projects/{project_id}/pronunciation-dictionaries/post(Create_Pronunciation_Dictionaries_v1_studio_projects__project_id__pronunciation_dictionaries_post)`.
    public func Create_Pronunciation_Dictionaries_v1_studio_projects__project_id__pronunciation_dictionaries_post(_ input: Operations.Create_Pronunciation_Dictionaries_v1_studio_projects__project_id__pronunciation_dictionaries_post.Input) async throws -> Operations.Create_Pronunciation_Dictionaries_v1_studio_projects__project_id__pronunciation_dictionaries_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Create_Pronunciation_Dictionaries_v1_studio_projects__project_id__pronunciation_dictionaries_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/studio/projects/{}/pronunciation-dictionaries",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_Pronunciation_Dictionaries_v1_studio_projects__project_id__pronunciation_dictionaries_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_Pronunciation_Dictionaries_v1_studio_projects__project_id__pronunciation_dictionaries_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Pronunciation Dictionaries
    ///
    /// Updates the set of pronunciation dictionaries acting on a project. This will automatically mark text within this project as requiring reconverting where the new dictionary would apply or the old one no longer does.
    ///
    /// - Remark: HTTP `POST /v1/projects/{project_id}/update-pronunciation-dictionaries`.
    /// - Remark: Generated from `#/paths//v1/projects/{project_id}/update-pronunciation-dictionaries/post(Update_Pronunciation_Dictionaries_v1_projects__project_id__update_pronunciation_dictionaries_post)`.
    @available(*, deprecated)
    public func Update_Pronunciation_Dictionaries_v1_projects__project_id__update_pronunciation_dictionaries_post(_ input: Operations.Update_Pronunciation_Dictionaries_v1_projects__project_id__update_pronunciation_dictionaries_post.Input) async throws -> Operations.Update_Pronunciation_Dictionaries_v1_projects__project_id__update_pronunciation_dictionaries_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Update_Pronunciation_Dictionaries_v1_projects__project_id__update_pronunciation_dictionaries_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/projects/{}/update-pronunciation-dictionaries",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_Pronunciation_Dictionaries_v1_projects__project_id__update_pronunciation_dictionaries_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_Pronunciation_Dictionaries_v1_projects__project_id__update_pronunciation_dictionaries_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Dub A Video Or An Audio File
    ///
    /// Dubs provided audio or video file into given language.
    ///
    /// - Remark: HTTP `POST /v1/dubbing`.
    /// - Remark: Generated from `#/paths//v1/dubbing/post(Dub_a_video_or_an_audio_file_v1_dubbing_post)`.
    public func Dub_a_video_or_an_audio_file_v1_dubbing_post(_ input: Operations.Dub_a_video_or_an_audio_file_v1_dubbing_post.Input) async throws -> Operations.Dub_a_video_or_an_audio_file_v1_dubbing_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Dub_a_video_or_an_audio_file_v1_dubbing_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/dubbing",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Dub_a_video_or_an_audio_file_v1_dubbing_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DoDubbingResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Dub_a_video_or_an_audio_file_v1_dubbing_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Dubbing Project Metadata
    ///
    /// Returns metadata about a dubbing project, including whether it's still in progress or not
    ///
    /// - Remark: HTTP `GET /v1/dubbing/{dubbing_id}`.
    /// - Remark: Generated from `#/paths//v1/dubbing/{dubbing_id}/get(Get_dubbing_project_metadata_v1_dubbing__dubbing_id__get)`.
    public func Get_dubbing_project_metadata_v1_dubbing__dubbing_id__get(_ input: Operations.Get_dubbing_project_metadata_v1_dubbing__dubbing_id__get.Input) async throws -> Operations.Get_dubbing_project_metadata_v1_dubbing__dubbing_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_dubbing_project_metadata_v1_dubbing__dubbing_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/dubbing/{}",
                    parameters: [
                        input.path.dubbing_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_dubbing_project_metadata_v1_dubbing__dubbing_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DubbingMetadataResponse.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_dubbing_project_metadata_v1_dubbing__dubbing_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Dubbing Project
    ///
    /// Deletes a dubbing project.
    ///
    /// - Remark: HTTP `DELETE /v1/dubbing/{dubbing_id}`.
    /// - Remark: Generated from `#/paths//v1/dubbing/{dubbing_id}/delete(Delete_dubbing_project_v1_dubbing__dubbing_id__delete)`.
    public func Delete_dubbing_project_v1_dubbing__dubbing_id__delete(_ input: Operations.Delete_dubbing_project_v1_dubbing__dubbing_id__delete.Input) async throws -> Operations.Delete_dubbing_project_v1_dubbing__dubbing_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_dubbing_project_v1_dubbing__dubbing_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/dubbing/{}",
                    parameters: [
                        input.path.dubbing_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_dubbing_project_v1_dubbing__dubbing_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_dubbing_project_v1_dubbing__dubbing_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Dubbed File
    ///
    /// Returns dubbed file as a streamed file. Videos will be returned in MP4 format and audio only dubs will be returned in MP3.
    ///
    /// - Remark: HTTP `GET /v1/dubbing/{dubbing_id}/audio/{language_code}`.
    /// - Remark: Generated from `#/paths//v1/dubbing/{dubbing_id}/audio/{language_code}/get(Get_dubbed_file_v1_dubbing__dubbing_id__audio__language_code__get)`.
    public func Get_dubbed_file_v1_dubbing__dubbing_id__audio__language_code__get(_ input: Operations.Get_dubbed_file_v1_dubbing__dubbing_id__audio__language_code__get.Input) async throws -> Operations.Get_dubbed_file_v1_dubbing__dubbing_id__audio__language_code__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_dubbed_file_v1_dubbing__dubbing_id__audio__language_code__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/dubbing/{}/audio/{}",
                    parameters: [
                        input.path.dubbing_id,
                        input.path.language_code
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_dubbed_file_v1_dubbing__dubbing_id__audio__language_code__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/octet-stream"
                        ]
                    )
                    switch chosenContentType {
                    case "application/octet-stream":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .binary(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_dubbed_file_v1_dubbing__dubbing_id__audio__language_code__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Transcript For Dub
    ///
    /// Returns transcript for the dub as an SRT file.
    ///
    /// - Remark: HTTP `GET /v1/dubbing/{dubbing_id}/transcript/{language_code}`.
    /// - Remark: Generated from `#/paths//v1/dubbing/{dubbing_id}/transcript/{language_code}/get(Get_transcript_for_dub_v1_dubbing__dubbing_id__transcript__language_code__get)`.
    public func Get_transcript_for_dub_v1_dubbing__dubbing_id__transcript__language_code__get(_ input: Operations.Get_transcript_for_dub_v1_dubbing__dubbing_id__transcript__language_code__get.Input) async throws -> Operations.Get_transcript_for_dub_v1_dubbing__dubbing_id__transcript__language_code__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_transcript_for_dub_v1_dubbing__dubbing_id__transcript__language_code__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/dubbing/{}/transcript/{}",
                    parameters: [
                        input.path.dubbing_id,
                        input.path.language_code
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "format_type",
                    value: input.query.format_type
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_transcript_for_dub_v1_dubbing__dubbing_id__transcript__language_code__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json",
                            "application/text"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    case "application/text":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .application_text(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_transcript_for_dub_v1_dubbing__dubbing_id__transcript__language_code__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Models
    ///
    /// Gets a list of available models.
    ///
    /// - Remark: HTTP `GET /v1/models`.
    /// - Remark: Generated from `#/paths//v1/models/get(Get_Models_v1_models_get)`.
    public func Get_Models_v1_models_get(_ input: Operations.Get_Models_v1_models_get.Input) async throws -> Operations.Get_Models_v1_models_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_Models_v1_models_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/models",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Models_v1_models_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.ModelResponseModel].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Models_v1_models_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Creates Audionative Enabled Project.
    ///
    /// Creates AudioNative enabled project, optionally starts conversion and returns project id and embeddable html snippet.
    ///
    /// - Remark: HTTP `POST /v1/audio-native`.
    /// - Remark: Generated from `#/paths//v1/audio-native/post(Creates_AudioNative_enabled_project__v1_audio_native_post)`.
    public func Creates_AudioNative_enabled_project__v1_audio_native_post(_ input: Operations.Creates_AudioNative_enabled_project__v1_audio_native_post.Input) async throws -> Operations.Creates_AudioNative_enabled_project__v1_audio_native_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Creates_AudioNative_enabled_project__v1_audio_native_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/audio-native",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "name"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "author",
                            "auto_convert",
                            "background_color",
                            "file",
                            "image",
                            "model_id",
                            "sessionization",
                            "small",
                            "text_color",
                            "title",
                            "voice_id"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .name(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "name",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .image(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "image",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .author(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "author",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .title(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "title",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .small(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "small",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .text_color(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "text_color",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .background_color(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "background_color",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .sessionization(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "sessionization",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .voice_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "voice_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .model_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "model_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .file(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "file",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .auto_convert(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "auto_convert",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Creates_AudioNative_enabled_project__v1_audio_native_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AudioNativeCreateProjectResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Creates_AudioNative_enabled_project__v1_audio_native_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Audio-Native Project Content
    ///
    /// Updates content for the specific AudioNative Project.
    ///
    /// - Remark: HTTP `POST /v1/audio-native/{project_id}/content`.
    /// - Remark: Generated from `#/paths//v1/audio-native/{project_id}/content/post(Update_audio_native_Project_content_v1_audio_native__project_id__content_post)`.
    public func Update_audio_native_Project_content_v1_audio_native__project_id__content_post(_ input: Operations.Update_audio_native_Project_content_v1_audio_native__project_id__content_post.Input) async throws -> Operations.Update_audio_native_Project_content_v1_audio_native__project_id__content_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Update_audio_native_Project_content_v1_audio_native__project_id__content_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/audio-native/{}/content",
                    parameters: [
                        input.path.project_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_audio_native_Project_content_v1_audio_native__project_id__content_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AudioNativeEditContentResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_audio_native_Project_content_v1_audio_native__project_id__content_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Voices
    ///
    /// Gets a list of shared voices.
    ///
    /// - Remark: HTTP `GET /v1/shared-voices`.
    /// - Remark: Generated from `#/paths//v1/shared-voices/get(Get_voices_v1_shared_voices_get)`.
    public func Get_voices_v1_shared_voices_get(_ input: Operations.Get_voices_v1_shared_voices_get.Input) async throws -> Operations.Get_voices_v1_shared_voices_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_voices_v1_shared_voices_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/shared-voices",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_size",
                    value: input.query.page_size
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "category",
                    value: input.query.category
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "gender",
                    value: input.query.gender
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "age",
                    value: input.query.age
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "accent",
                    value: input.query.accent
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "language",
                    value: input.query.language
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "search",
                    value: input.query.search
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "use_cases",
                    value: input.query.use_cases
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "descriptives",
                    value: input.query.descriptives
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "featured",
                    value: input.query.featured
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "reader_app_enabled",
                    value: input.query.reader_app_enabled
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "owner_id",
                    value: input.query.owner_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "sort",
                    value: input.query.sort
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page",
                    value: input.query.page
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voices_v1_shared_voices_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetLibraryVoicesResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_voices_v1_shared_voices_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Similar Library Voices
    ///
    /// Returns a list of shared voices similar to the provided audio sample. If neither similarity_threshold nor top_k is provided, we will apply default values.
    ///
    /// - Remark: HTTP `POST /v1/similar-voices`.
    /// - Remark: Generated from `#/paths//v1/similar-voices/post(Get_similar_library_voices_v1_similar_voices_post)`.
    public func Get_similar_library_voices_v1_similar_voices_post(_ input: Operations.Get_similar_library_voices_v1_similar_voices_post.Input) async throws -> Operations.Get_similar_library_voices_v1_similar_voices_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_similar_library_voices_v1_similar_voices_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/similar-voices",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_similar_library_voices_v1_similar_voices_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetLibraryVoicesResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_similar_library_voices_v1_similar_voices_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Characters Usage Metrics
    ///
    /// Returns the credit usage metrics for the current user or the entire workspace they are part of. The response will return a time axis with unix timestamps for each day and daily usage along that axis. The usage will be broken down by the specified breakdown type. For example, breakdown type "voice" will return the usage of each voice along the time axis.
    ///
    /// - Remark: HTTP `GET /v1/usage/character-stats`.
    /// - Remark: Generated from `#/paths//v1/usage/character-stats/get(Get_characters_usage_metrics_v1_usage_character_stats_get)`.
    public func Get_characters_usage_metrics_v1_usage_character_stats_get(_ input: Operations.Get_characters_usage_metrics_v1_usage_character_stats_get.Input) async throws -> Operations.Get_characters_usage_metrics_v1_usage_character_stats_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_characters_usage_metrics_v1_usage_character_stats_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/usage/character-stats",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start_unix",
                    value: input.query.start_unix
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end_unix",
                    value: input.query.end_unix
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "include_workspace_metrics",
                    value: input.query.include_workspace_metrics
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "breakdown_type",
                    value: input.query.breakdown_type
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_characters_usage_metrics_v1_usage_character_stats_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.UsageCharactersResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_characters_usage_metrics_v1_usage_character_stats_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add A Pronunciation Dictionary
    ///
    /// Creates a new pronunciation dictionary from a lexicon .PLS file
    ///
    /// - Remark: HTTP `POST /v1/pronunciation-dictionaries/add-from-file`.
    /// - Remark: Generated from `#/paths//v1/pronunciation-dictionaries/add-from-file/post(Add_a_pronunciation_dictionary_v1_pronunciation_dictionaries_add_from_file_post)`.
    public func Add_a_pronunciation_dictionary_v1_pronunciation_dictionaries_add_from_file_post(_ input: Operations.Add_a_pronunciation_dictionary_v1_pronunciation_dictionaries_add_from_file_post.Input) async throws -> Operations.Add_a_pronunciation_dictionary_v1_pronunciation_dictionaries_add_from_file_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_a_pronunciation_dictionary_v1_pronunciation_dictionaries_add_from_file_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/pronunciation-dictionaries/add-from-file",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "name"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "description",
                            "file",
                            "workspace_access"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .name(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "name",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .file(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "file",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .description(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "description",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .workspace_access(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "workspace_access",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_a_pronunciation_dictionary_v1_pronunciation_dictionaries_add_from_file_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddPronunciationDictionaryResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_a_pronunciation_dictionary_v1_pronunciation_dictionaries_add_from_file_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add Rules To The Pronunciation Dictionary
    ///
    /// Add rules to the pronunciation dictionary
    ///
    /// - Remark: HTTP `POST /v1/pronunciation-dictionaries/{pronunciation_dictionary_id}/add-rules`.
    /// - Remark: Generated from `#/paths//v1/pronunciation-dictionaries/{pronunciation_dictionary_id}/add-rules/post(Add_rules_to_the_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id__add_rules_post)`.
    public func Add_rules_to_the_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id__add_rules_post(_ input: Operations.Add_rules_to_the_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id__add_rules_post.Input) async throws -> Operations.Add_rules_to_the_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id__add_rules_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_rules_to_the_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id__add_rules_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/pronunciation-dictionaries/{}/add-rules",
                    parameters: [
                        input.path.pronunciation_dictionary_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_rules_to_the_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id__add_rules_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddPronunciationDictionaryRulesResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_rules_to_the_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id__add_rules_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Remove Rules From The Pronunciation Dictionary
    ///
    /// Remove rules from the pronunciation dictionary
    ///
    /// - Remark: HTTP `POST /v1/pronunciation-dictionaries/{pronunciation_dictionary_id}/remove-rules`.
    /// - Remark: Generated from `#/paths//v1/pronunciation-dictionaries/{pronunciation_dictionary_id}/remove-rules/post(Remove_rules_from_the_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id__remove_rules_post)`.
    public func Remove_rules_from_the_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id__remove_rules_post(_ input: Operations.Remove_rules_from_the_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id__remove_rules_post.Input) async throws -> Operations.Remove_rules_from_the_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id__remove_rules_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Remove_rules_from_the_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id__remove_rules_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/pronunciation-dictionaries/{}/remove-rules",
                    parameters: [
                        input.path.pronunciation_dictionary_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Remove_rules_from_the_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id__remove_rules_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.RemovePronunciationDictionaryRulesResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Remove_rules_from_the_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id__remove_rules_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Pls File With A Pronunciation Dictionary Version Rules
    ///
    /// Get PLS file with a pronunciation dictionary version rules
    ///
    /// - Remark: HTTP `GET /v1/pronunciation-dictionaries/{dictionary_id}/{version_id}/download`.
    /// - Remark: Generated from `#/paths//v1/pronunciation-dictionaries/{dictionary_id}/{version_id}/download/get(Get_PLS_file_with_a_pronunciation_dictionary_version_rules_v1_pronunciation_dictionaries__dictionary_id___version_id__download_get)`.
    public func Get_PLS_file_with_a_pronunciation_dictionary_version_rules_v1_pronunciation_dictionaries__dictionary_id___version_id__download_get(_ input: Operations.Get_PLS_file_with_a_pronunciation_dictionary_version_rules_v1_pronunciation_dictionaries__dictionary_id___version_id__download_get.Input) async throws -> Operations.Get_PLS_file_with_a_pronunciation_dictionary_version_rules_v1_pronunciation_dictionaries__dictionary_id___version_id__download_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_PLS_file_with_a_pronunciation_dictionary_version_rules_v1_pronunciation_dictionaries__dictionary_id___version_id__download_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/pronunciation-dictionaries/{}/{}/download",
                    parameters: [
                        input.path.dictionary_id,
                        input.path.version_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_PLS_file_with_a_pronunciation_dictionary_version_rules_v1_pronunciation_dictionaries__dictionary_id___version_id__download_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "text/plain"
                        ]
                    )
                    switch chosenContentType {
                    case "text/plain":
                        body = try converter.getResponseBodyAsBinary(
                            OpenAPIRuntime.HTTPBody.self,
                            from: responseBody,
                            transforming: { value in
                                .plainText(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_PLS_file_with_a_pronunciation_dictionary_version_rules_v1_pronunciation_dictionaries__dictionary_id___version_id__download_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Metadata For A Pronunciation Dictionary
    ///
    /// Get metadata for a pronunciation dictionary
    ///
    /// - Remark: HTTP `GET /v1/pronunciation-dictionaries/{pronunciation_dictionary_id}/`.
    /// - Remark: Generated from `#/paths//v1/pronunciation-dictionaries/{pronunciation_dictionary_id}//get(Get_metadata_for_a_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id___get)`.
    public func Get_metadata_for_a_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id___get(_ input: Operations.Get_metadata_for_a_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id___get.Input) async throws -> Operations.Get_metadata_for_a_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id___get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_metadata_for_a_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id___get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/pronunciation-dictionaries/{}/",
                    parameters: [
                        input.path.pronunciation_dictionary_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_metadata_for_a_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id___get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetPronunciationDictionaryMetadataResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_metadata_for_a_pronunciation_dictionary_v1_pronunciation_dictionaries__pronunciation_dictionary_id___get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Pronunciation Dictionaries
    ///
    /// Get a list of the pronunciation dictionaries you have access to and their metadata
    ///
    /// - Remark: HTTP `GET /v1/pronunciation-dictionaries/`.
    /// - Remark: Generated from `#/paths//v1/pronunciation-dictionaries//get(Get_Pronunciation_Dictionaries_v1_pronunciation_dictionaries__get)`.
    public func Get_Pronunciation_Dictionaries_v1_pronunciation_dictionaries__get(_ input: Operations.Get_Pronunciation_Dictionaries_v1_pronunciation_dictionaries__get.Input) async throws -> Operations.Get_Pronunciation_Dictionaries_v1_pronunciation_dictionaries__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_Pronunciation_Dictionaries_v1_pronunciation_dictionaries__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/pronunciation-dictionaries/",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "cursor",
                    value: input.query.cursor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_size",
                    value: input.query.page_size
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Pronunciation_Dictionaries_v1_pronunciation_dictionaries__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetPronunciationDictionariesMetadataResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Pronunciation_Dictionaries_v1_pronunciation_dictionaries__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Search User Groups
    ///
    /// Searches for user groups in the workspace. Multiple or no groups may be returned.
    ///
    /// - Remark: HTTP `GET /v1/workspace/groups/search`.
    /// - Remark: Generated from `#/paths//v1/workspace/groups/search/get(Search_user_groups_v1_workspace_groups_search_get)`.
    public func Search_user_groups_v1_workspace_groups_search_get(_ input: Operations.Search_user_groups_v1_workspace_groups_search_get.Input) async throws -> Operations.Search_user_groups_v1_workspace_groups_search_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Search_user_groups_v1_workspace_groups_search_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/workspace/groups/search",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "name",
                    value: input.query.name
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Search_user_groups_v1_workspace_groups_search_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.WorkspaceGroupByNameResponseModel].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Search_user_groups_v1_workspace_groups_search_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Member From User Group
    ///
    /// Removes a member from the specified group. This endpoint may only be called by workspace administrators.
    ///
    /// - Remark: HTTP `POST /v1/workspace/groups/{group_id}/members/remove`.
    /// - Remark: Generated from `#/paths//v1/workspace/groups/{group_id}/members/remove/post(Delete_member_from_user_group_v1_workspace_groups__group_id__members_remove_post)`.
    public func Delete_member_from_user_group_v1_workspace_groups__group_id__members_remove_post(_ input: Operations.Delete_member_from_user_group_v1_workspace_groups__group_id__members_remove_post.Input) async throws -> Operations.Delete_member_from_user_group_v1_workspace_groups__group_id__members_remove_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_member_from_user_group_v1_workspace_groups__group_id__members_remove_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/workspace/groups/{}/members/remove",
                    parameters: [
                        input.path.group_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_member_from_user_group_v1_workspace_groups__group_id__members_remove_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_member_from_user_group_v1_workspace_groups__group_id__members_remove_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add Member To User Group
    ///
    /// Adds a member of your workspace to the specified group. This endpoint may only be called by workspace administrators.
    ///
    /// - Remark: HTTP `POST /v1/workspace/groups/{group_id}/members`.
    /// - Remark: Generated from `#/paths//v1/workspace/groups/{group_id}/members/post(Add_member_to_user_group_v1_workspace_groups__group_id__members_post)`.
    public func Add_member_to_user_group_v1_workspace_groups__group_id__members_post(_ input: Operations.Add_member_to_user_group_v1_workspace_groups__group_id__members_post.Input) async throws -> Operations.Add_member_to_user_group_v1_workspace_groups__group_id__members_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_member_to_user_group_v1_workspace_groups__group_id__members_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/workspace/groups/{}/members",
                    parameters: [
                        input.path.group_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_member_to_user_group_v1_workspace_groups__group_id__members_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_member_to_user_group_v1_workspace_groups__group_id__members_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Invite User
    ///
    /// Sends an email invitation to join your workspace to the provided email. If the user doesn't have an account they will be prompted to create one. If the user accepts this invite they will be added as a user to your workspace and your subscription using one of your seats. This endpoint may only be called by workspace administrators. If the user is already in the workspace a 400 error will be returned.
    ///
    /// - Remark: HTTP `POST /v1/workspace/invites/add`.
    /// - Remark: Generated from `#/paths//v1/workspace/invites/add/post(Invite_user_v1_workspace_invites_add_post)`.
    public func Invite_user_v1_workspace_invites_add_post(_ input: Operations.Invite_user_v1_workspace_invites_add_post.Input) async throws -> Operations.Invite_user_v1_workspace_invites_add_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Invite_user_v1_workspace_invites_add_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/workspace/invites/add",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Invite_user_v1_workspace_invites_add_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Invite_user_v1_workspace_invites_add_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Invite Multiple Users
    ///
    /// Sends email invitations to join your workspace to the provided emails. Requires all email addresses to be part of a verified domain. If the users don't have an account they will be prompted to create one. If the users accept these invites they will be added as users to your workspace and your subscription using one of your seats. This endpoint may only be called by workspace administrators.
    ///
    /// - Remark: HTTP `POST /v1/workspace/invites/add-bulk`.
    /// - Remark: Generated from `#/paths//v1/workspace/invites/add-bulk/post(Invite_multiple_users_v1_workspace_invites_add_bulk_post)`.
    public func Invite_multiple_users_v1_workspace_invites_add_bulk_post(_ input: Operations.Invite_multiple_users_v1_workspace_invites_add_bulk_post.Input) async throws -> Operations.Invite_multiple_users_v1_workspace_invites_add_bulk_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Invite_multiple_users_v1_workspace_invites_add_bulk_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/workspace/invites/add-bulk",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Invite_multiple_users_v1_workspace_invites_add_bulk_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Invite_multiple_users_v1_workspace_invites_add_bulk_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Existing Invitation
    ///
    /// Invalidates an existing email invitation. The invitation will still show up in the inbox it has been delivered to, but activating it to join the workspace won't work. This endpoint may only be called by workspace administrators.
    ///
    /// - Remark: HTTP `DELETE /v1/workspace/invites`.
    /// - Remark: Generated from `#/paths//v1/workspace/invites/delete(Delete_existing_invitation_v1_workspace_invites_delete)`.
    public func Delete_existing_invitation_v1_workspace_invites_delete(_ input: Operations.Delete_existing_invitation_v1_workspace_invites_delete.Input) async throws -> Operations.Delete_existing_invitation_v1_workspace_invites_delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_existing_invitation_v1_workspace_invites_delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/workspace/invites",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_existing_invitation_v1_workspace_invites_delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_existing_invitation_v1_workspace_invites_delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Member
    ///
    /// Updates attributes of a workspace member. Apart from the email identifier, all parameters will remain unchanged unless specified. This endpoint may only be called by workspace administrators.
    ///
    /// - Remark: HTTP `POST /v1/workspace/members`.
    /// - Remark: Generated from `#/paths//v1/workspace/members/post(Update_member_v1_workspace_members_post)`.
    public func Update_member_v1_workspace_members_post(_ input: Operations.Update_member_v1_workspace_members_post.Input) async throws -> Operations.Update_member_v1_workspace_members_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Update_member_v1_workspace_members_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/workspace/members",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_member_v1_workspace_members_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_member_v1_workspace_members_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get A Profile Page
    ///
    /// Gets a profile page based on a handle
    ///
    /// - Remark: HTTP `GET /profile/{handle}`.
    /// - Remark: Generated from `#/paths//profile/{handle}/get(Get_a_profile_page_profile__handle__get)`.
    public func Get_a_profile_page_profile__handle__get(_ input: Operations.Get_a_profile_page_profile__handle__get.Input) async throws -> Operations.Get_a_profile_page_profile__handle__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_a_profile_page_profile__handle__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/profile/{}",
                    parameters: [
                        input.path.handle
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_a_profile_page_profile__handle__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ProfilePageResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_a_profile_page_profile__handle__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Speech To Text
    ///
    /// Transcribe an audio or video file.
    ///
    /// - Remark: HTTP `POST /v1/speech-to-text`.
    /// - Remark: Generated from `#/paths//v1/speech-to-text/post(Speech_to_Text_v1_speech_to_text_post)`.
    public func Speech_to_Text_v1_speech_to_text_post(_ input: Operations.Speech_to_Text_v1_speech_to_text_post.Input) async throws -> Operations.Speech_to_Text_v1_speech_to_text_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Speech_to_Text_v1_speech_to_text_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/speech-to-text",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "model_id"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "file",
                            "language_code",
                            "num_speakers",
                            "tag_audio_events"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .model_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "model_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .file(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "file",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .language_code(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "language_code",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .tag_audio_events(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "tag_audio_events",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .num_speakers(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "num_speakers",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Speech_to_Text_v1_speech_to_text_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SpeechToTextChunkResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Speech_to_Text_v1_speech_to_text_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Speech To Text Stream
    ///
    /// Transcribe an audio or video file with streaming response. Returns chunks of transcription as they become available, with each chunk separated by double newlines (\n\n).
    ///
    /// - Remark: HTTP `POST /v1/speech-to-text/stream`.
    /// - Remark: Generated from `#/paths//v1/speech-to-text/stream/post(Speech_to_Text_Stream_v1_speech_to_text_stream_post)`.
    public func Speech_to_Text_Stream_v1_speech_to_text_stream_post(_ input: Operations.Speech_to_Text_Stream_v1_speech_to_text_stream_post.Input) async throws -> Operations.Speech_to_Text_Stream_v1_speech_to_text_stream_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Speech_to_Text_Stream_v1_speech_to_text_stream_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/speech-to-text/stream",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "model_id"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [
                            "file",
                            "language_code",
                            "num_speakers",
                            "tag_audio_events"
                        ],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .model_id(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "model_id",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .file(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "file",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .language_code(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "language_code",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .tag_audio_events(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "tag_audio_events",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .num_speakers(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "num_speakers",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Speech_to_Text_Stream_v1_speech_to_text_stream_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.SpeechToTextStreamResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Speech_to_Text_Stream_v1_speech_to_text_stream_post.Output.BadRequest.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .badRequest(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Speech_to_Text_Stream_v1_speech_to_text_stream_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Signed Url
    ///
    /// Get a signed url to start a conversation with an agent with an agent that requires authorization
    ///
    /// - Remark: HTTP `GET /v1/convai/conversation/get_signed_url`.
    /// - Remark: Generated from `#/paths//v1/convai/conversation/get_signed_url/get(Get_Signed_Url_v1_convai_conversation_get_signed_url_get)`.
    public func Get_Signed_Url_v1_convai_conversation_get_signed_url_get(_ input: Operations.Get_Signed_Url_v1_convai_conversation_get_signed_url_get.Input) async throws -> Operations.Get_Signed_Url_v1_convai_conversation_get_signed_url_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_Signed_Url_v1_convai_conversation_get_signed_url_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/conversation/get_signed_url",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "agent_id",
                    value: input.query.agent_id
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Signed_Url_v1_convai_conversation_get_signed_url_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ConversationSignedUrlResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Signed_Url_v1_convai_conversation_get_signed_url_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Create Agent
    ///
    /// Create an agent from a config object
    ///
    /// - Remark: HTTP `POST /v1/convai/agents/create`.
    /// - Remark: Generated from `#/paths//v1/convai/agents/create/post(Create_Agent_v1_convai_agents_create_post)`.
    public func Create_Agent_v1_convai_agents_create_post(_ input: Operations.Create_Agent_v1_convai_agents_create_post.Input) async throws -> Operations.Create_Agent_v1_convai_agents_create_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Create_Agent_v1_convai_agents_create_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/agents/create",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "use_tool_ids",
                    value: input.query.use_tool_ids
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_Agent_v1_convai_agents_create_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CreateAgentResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Create_Agent_v1_convai_agents_create_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Agent
    ///
    /// Retrieve config for an agent
    ///
    /// - Remark: HTTP `GET /v1/convai/agents/{agent_id}`.
    /// - Remark: Generated from `#/paths//v1/convai/agents/{agent_id}/get(Get_Agent_v1_convai_agents__agent_id__get)`.
    public func Get_Agent_v1_convai_agents__agent_id__get(_ input: Operations.Get_Agent_v1_convai_agents__agent_id__get.Input) async throws -> Operations.Get_Agent_v1_convai_agents__agent_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_Agent_v1_convai_agents__agent_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/agents/{}",
                    parameters: [
                        input.path.agent_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Agent_v1_convai_agents__agent_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetAgentResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Agent_v1_convai_agents__agent_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Patches An Agent Settings
    ///
    /// Patches an Agent settings
    ///
    /// - Remark: HTTP `PATCH /v1/convai/agents/{agent_id}`.
    /// - Remark: Generated from `#/paths//v1/convai/agents/{agent_id}/patch(Patches_an_Agent_settings_v1_convai_agents__agent_id__patch)`.
    public func Patches_an_Agent_settings_v1_convai_agents__agent_id__patch(_ input: Operations.Patches_an_Agent_settings_v1_convai_agents__agent_id__patch.Input) async throws -> Operations.Patches_an_Agent_settings_v1_convai_agents__agent_id__patch.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Patches_an_Agent_settings_v1_convai_agents__agent_id__patch.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/agents/{}",
                    parameters: [
                        input.path.agent_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "use_tool_ids",
                    value: input.query.use_tool_ids
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none:
                    body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Patches_an_Agent_settings_v1_convai_agents__agent_id__patch.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetAgentResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Patches_an_Agent_settings_v1_convai_agents__agent_id__patch.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Agent
    ///
    /// Delete an agent
    ///
    /// - Remark: HTTP `DELETE /v1/convai/agents/{agent_id}`.
    /// - Remark: Generated from `#/paths//v1/convai/agents/{agent_id}/delete(Delete_Agent_v1_convai_agents__agent_id__delete)`.
    public func Delete_Agent_v1_convai_agents__agent_id__delete(_ input: Operations.Delete_Agent_v1_convai_agents__agent_id__delete.Input) async throws -> Operations.Delete_Agent_v1_convai_agents__agent_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_Agent_v1_convai_agents__agent_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/agents/{}",
                    parameters: [
                        input.path.agent_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_Agent_v1_convai_agents__agent_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_Agent_v1_convai_agents__agent_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Agent Widget Config
    ///
    /// Retrieve the widget configuration for an agent
    ///
    /// - Remark: HTTP `GET /v1/convai/agents/{agent_id}/widget`.
    /// - Remark: Generated from `#/paths//v1/convai/agents/{agent_id}/widget/get(Get_Agent_widget_config_v1_convai_agents__agent_id__widget_get)`.
    public func Get_Agent_widget_config_v1_convai_agents__agent_id__widget_get(_ input: Operations.Get_Agent_widget_config_v1_convai_agents__agent_id__widget_get.Input) async throws -> Operations.Get_Agent_widget_config_v1_convai_agents__agent_id__widget_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_Agent_widget_config_v1_convai_agents__agent_id__widget_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/agents/{}/widget",
                    parameters: [
                        input.path.agent_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "conversation_signature",
                    value: input.query.conversation_signature
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Agent_widget_config_v1_convai_agents__agent_id__widget_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetAgentEmbedResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Agent_widget_config_v1_convai_agents__agent_id__widget_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Shareable Agent Link
    ///
    /// Get the current link used to share the agent with others
    ///
    /// - Remark: HTTP `GET /v1/convai/agents/{agent_id}/link`.
    /// - Remark: Generated from `#/paths//v1/convai/agents/{agent_id}/link/get(Get_shareable_agent_link_v1_convai_agents__agent_id__link_get)`.
    public func Get_shareable_agent_link_v1_convai_agents__agent_id__link_get(_ input: Operations.Get_shareable_agent_link_v1_convai_agents__agent_id__link_get.Input) async throws -> Operations.Get_shareable_agent_link_v1_convai_agents__agent_id__link_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_shareable_agent_link_v1_convai_agents__agent_id__link_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/agents/{}/link",
                    parameters: [
                        input.path.agent_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_shareable_agent_link_v1_convai_agents__agent_id__link_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetAgentLinkResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_shareable_agent_link_v1_convai_agents__agent_id__link_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Post Agent Avatar
    ///
    /// Sets the avatar for an agent displayed in the widget
    ///
    /// - Remark: HTTP `POST /v1/convai/agents/{agent_id}/avatar`.
    /// - Remark: Generated from `#/paths//v1/convai/agents/{agent_id}/avatar/post(Post_Agent_avatar_v1_convai_agents__agent_id__avatar_post)`.
    public func Post_Agent_avatar_v1_convai_agents__agent_id__avatar_post(_ input: Operations.Post_Agent_avatar_v1_convai_agents__agent_id__avatar_post.Input) async throws -> Operations.Post_Agent_avatar_v1_convai_agents__agent_id__avatar_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Post_Agent_avatar_v1_convai_agents__agent_id__avatar_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/agents/{}/avatar",
                    parameters: [
                        input.path.agent_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .multipartForm(value):
                    body = try converter.setRequiredRequestBodyAsMultipart(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "multipart/form-data",
                        allowsUnknownParts: true,
                        requiredExactlyOncePartNames: [
                            "avatar_file"
                        ],
                        requiredAtLeastOncePartNames: [],
                        atMostOncePartNames: [],
                        zeroOrMoreTimesPartNames: [],
                        encoding: { part in
                            switch part {
                            case let .avatar_file(wrapped):
                                var headerFields: HTTPTypes.HTTPFields = .init()
                                let value = wrapped.payload
                                let body = try converter.setRequiredRequestBodyAsBinary(
                                    value.body,
                                    headerFields: &headerFields,
                                    contentType: "text/plain"
                                )
                                return .init(
                                    name: "avatar_file",
                                    filename: wrapped.filename,
                                    headerFields: headerFields,
                                    body: body
                                )
                            case let .undocumented(value):
                                return value
                            }
                        }
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Post_Agent_avatar_v1_convai_agents__agent_id__avatar_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.PostAgentAvatarResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Post_Agent_avatar_v1_convai_agents__agent_id__avatar_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add A Secret To The Agent Which Can Be Referenced In Tool Calls
    ///
    /// Uploads a file or reference a webpage for the agent to use as part of it's knowledge base
    ///
    /// - Remark: HTTP `POST /v1/convai/agents/{agent_id}/add-secret`.
    /// - Remark: Generated from `#/paths//v1/convai/agents/{agent_id}/add-secret/post(Add_a_secret_to_the_Agent_which_can_be_referenced_in_tool_calls_v1_convai_agents__agent_id__add_secret_post)`.
    public func Add_a_secret_to_the_Agent_which_can_be_referenced_in_tool_calls_v1_convai_agents__agent_id__add_secret_post(_ input: Operations.Add_a_secret_to_the_Agent_which_can_be_referenced_in_tool_calls_v1_convai_agents__agent_id__add_secret_post.Input) async throws -> Operations.Add_a_secret_to_the_Agent_which_can_be_referenced_in_tool_calls_v1_convai_agents__agent_id__add_secret_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_a_secret_to_the_Agent_which_can_be_referenced_in_tool_calls_v1_convai_agents__agent_id__add_secret_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/agents/{}/add-secret",
                    parameters: [
                        input.path.agent_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_a_secret_to_the_Agent_which_can_be_referenced_in_tool_calls_v1_convai_agents__agent_id__add_secret_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddAgentSecretResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_a_secret_to_the_Agent_which_can_be_referenced_in_tool_calls_v1_convai_agents__agent_id__add_secret_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Agents Page
    ///
    /// Returns a page of your agents and their metadata.
    ///
    /// - Remark: HTTP `GET /v1/convai/agents`.
    /// - Remark: Generated from `#/paths//v1/convai/agents/get(Get_agents_page_v1_convai_agents_get)`.
    public func Get_agents_page_v1_convai_agents_get(_ input: Operations.Get_agents_page_v1_convai_agents_get.Input) async throws -> Operations.Get_agents_page_v1_convai_agents_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_agents_page_v1_convai_agents_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/agents",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "cursor",
                    value: input.query.cursor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_size",
                    value: input.query.page_size
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "search",
                    value: input.query.search
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_agents_page_v1_convai_agents_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetAgentsPageResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_agents_page_v1_convai_agents_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Conversations
    ///
    /// Get all conversations of agents that user owns. With option to restrict to a specific agent.
    ///
    /// - Remark: HTTP `GET /v1/convai/conversations`.
    /// - Remark: Generated from `#/paths//v1/convai/conversations/get(Get_Conversations_v1_convai_conversations_get)`.
    public func Get_Conversations_v1_convai_conversations_get(_ input: Operations.Get_Conversations_v1_convai_conversations_get.Input) async throws -> Operations.Get_Conversations_v1_convai_conversations_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_Conversations_v1_convai_conversations_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/conversations",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "cursor",
                    value: input.query.cursor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "agent_id",
                    value: input.query.agent_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "call_successful",
                    value: input.query.call_successful
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_size",
                    value: input.query.page_size
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Conversations_v1_convai_conversations_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetConversationsPageResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Conversations_v1_convai_conversations_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Conversation Details
    ///
    /// Get the details of a particular conversation
    ///
    /// - Remark: HTTP `GET /v1/convai/conversations/{conversation_id}`.
    /// - Remark: Generated from `#/paths//v1/convai/conversations/{conversation_id}/get(Get_Conversation_Details_v1_convai_conversations__conversation_id__get)`.
    public func Get_Conversation_Details_v1_convai_conversations__conversation_id__get(_ input: Operations.Get_Conversation_Details_v1_convai_conversations__conversation_id__get.Input) async throws -> Operations.Get_Conversation_Details_v1_convai_conversations__conversation_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_Conversation_Details_v1_convai_conversations__conversation_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/conversations/{}",
                    parameters: [
                        input.path.conversation_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Conversation_Details_v1_convai_conversations__conversation_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetConversationResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Conversation_Details_v1_convai_conversations__conversation_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Conversation
    ///
    /// Delete a particular conversation
    ///
    /// - Remark: HTTP `DELETE /v1/convai/conversations/{conversation_id}`.
    /// - Remark: Generated from `#/paths//v1/convai/conversations/{conversation_id}/delete(Delete_Conversation_v1_convai_conversations__conversation_id__delete)`.
    public func Delete_Conversation_v1_convai_conversations__conversation_id__delete(_ input: Operations.Delete_Conversation_v1_convai_conversations__conversation_id__delete.Input) async throws -> Operations.Delete_Conversation_v1_convai_conversations__conversation_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_Conversation_v1_convai_conversations__conversation_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/conversations/{}",
                    parameters: [
                        input.path.conversation_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_Conversation_v1_convai_conversations__conversation_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_Conversation_v1_convai_conversations__conversation_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Conversation Audio
    ///
    /// Get the audio recording of a particular conversation
    ///
    /// - Remark: HTTP `GET /v1/convai/conversations/{conversation_id}/audio`.
    /// - Remark: Generated from `#/paths//v1/convai/conversations/{conversation_id}/audio/get(Get_Conversation_Audio_v1_convai_conversations__conversation_id__audio_get)`.
    public func Get_Conversation_Audio_v1_convai_conversations__conversation_id__audio_get(_ input: Operations.Get_Conversation_Audio_v1_convai_conversations__conversation_id__audio_get.Input) async throws -> Operations.Get_Conversation_Audio_v1_convai_conversations__conversation_id__audio_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_Conversation_Audio_v1_convai_conversations__conversation_id__audio_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/conversations/{}/audio",
                    parameters: [
                        input.path.conversation_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    return .ok(.init())
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_Conversation_Audio_v1_convai_conversations__conversation_id__audio_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Send Conversation Feedback
    ///
    /// Send the feedback for the given conversation
    ///
    /// - Remark: HTTP `POST /v1/convai/conversations/{conversation_id}/feedback`.
    /// - Remark: Generated from `#/paths//v1/convai/conversations/{conversation_id}/feedback/post(Send_Conversation_Feedback_v1_convai_conversations__conversation_id__feedback_post)`.
    public func Send_Conversation_Feedback_v1_convai_conversations__conversation_id__feedback_post(_ input: Operations.Send_Conversation_Feedback_v1_convai_conversations__conversation_id__feedback_post.Input) async throws -> Operations.Send_Conversation_Feedback_v1_convai_conversations__conversation_id__feedback_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Send_Conversation_Feedback_v1_convai_conversations__conversation_id__feedback_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/conversations/{}/feedback",
                    parameters: [
                        input.path.conversation_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Send_Conversation_Feedback_v1_convai_conversations__conversation_id__feedback_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Send_Conversation_Feedback_v1_convai_conversations__conversation_id__feedback_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Import Phone Number
    ///
    /// Import Phone Number from Twilio configuration
    ///
    /// - Remark: HTTP `POST /v1/convai/phone-numbers/create`.
    /// - Remark: Generated from `#/paths//v1/convai/phone-numbers/create/post(Import_phone_number_v1_convai_phone_numbers_create_post)`.
    public func Import_phone_number_v1_convai_phone_numbers_create_post(_ input: Operations.Import_phone_number_v1_convai_phone_numbers_create_post.Input) async throws -> Operations.Import_phone_number_v1_convai_phone_numbers_create_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Import_phone_number_v1_convai_phone_numbers_create_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/phone-numbers/create",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Import_phone_number_v1_convai_phone_numbers_create_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.CreatePhoneNumberResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Import_phone_number_v1_convai_phone_numbers_create_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Phone Number
    ///
    /// Retrieve Phone Number details by ID
    ///
    /// - Remark: HTTP `GET /v1/convai/phone-numbers/{phone_number_id}`.
    /// - Remark: Generated from `#/paths//v1/convai/phone-numbers/{phone_number_id}/get(Get_phone_number_v1_convai_phone_numbers__phone_number_id__get)`.
    public func Get_phone_number_v1_convai_phone_numbers__phone_number_id__get(_ input: Operations.Get_phone_number_v1_convai_phone_numbers__phone_number_id__get.Input) async throws -> Operations.Get_phone_number_v1_convai_phone_numbers__phone_number_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_phone_number_v1_convai_phone_numbers__phone_number_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/phone-numbers/{}",
                    parameters: [
                        input.path.phone_number_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_phone_number_v1_convai_phone_numbers__phone_number_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetPhoneNumberResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_phone_number_v1_convai_phone_numbers__phone_number_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Phone Number
    ///
    /// Update Phone Number details by ID
    ///
    /// - Remark: HTTP `PATCH /v1/convai/phone-numbers/{phone_number_id}`.
    /// - Remark: Generated from `#/paths//v1/convai/phone-numbers/{phone_number_id}/patch(Update_phone_number_v1_convai_phone_numbers__phone_number_id__patch)`.
    public func Update_phone_number_v1_convai_phone_numbers__phone_number_id__patch(_ input: Operations.Update_phone_number_v1_convai_phone_numbers__phone_number_id__patch.Input) async throws -> Operations.Update_phone_number_v1_convai_phone_numbers__phone_number_id__patch.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Update_phone_number_v1_convai_phone_numbers__phone_number_id__patch.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/phone-numbers/{}",
                    parameters: [
                        input.path.phone_number_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_phone_number_v1_convai_phone_numbers__phone_number_id__patch.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetPhoneNumberResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_phone_number_v1_convai_phone_numbers__phone_number_id__patch.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Phone Number
    ///
    /// Delete Phone Number by ID
    ///
    /// - Remark: HTTP `DELETE /v1/convai/phone-numbers/{phone_number_id}`.
    /// - Remark: Generated from `#/paths//v1/convai/phone-numbers/{phone_number_id}/delete(Delete_phone_number_v1_convai_phone_numbers__phone_number_id__delete)`.
    public func Delete_phone_number_v1_convai_phone_numbers__phone_number_id__delete(_ input: Operations.Delete_phone_number_v1_convai_phone_numbers__phone_number_id__delete.Input) async throws -> Operations.Delete_phone_number_v1_convai_phone_numbers__phone_number_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_phone_number_v1_convai_phone_numbers__phone_number_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/phone-numbers/{}",
                    parameters: [
                        input.path.phone_number_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_phone_number_v1_convai_phone_numbers__phone_number_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_phone_number_v1_convai_phone_numbers__phone_number_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// List Phone Numbers
    ///
    /// Retrieve all Phone Numbers
    ///
    /// - Remark: HTTP `GET /v1/convai/phone-numbers/`.
    /// - Remark: Generated from `#/paths//v1/convai/phone-numbers//get(List_phone_numbers_v1_convai_phone_numbers__get)`.
    public func List_phone_numbers_v1_convai_phone_numbers__get(_ input: Operations.List_phone_numbers_v1_convai_phone_numbers__get.Input) async throws -> Operations.List_phone_numbers_v1_convai_phone_numbers__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.List_phone_numbers_v1_convai_phone_numbers__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/phone-numbers/",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.List_phone_numbers_v1_convai_phone_numbers__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            [Components.Schemas.GetPhoneNumberResponseModel].self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.List_phone_numbers_v1_convai_phone_numbers__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Knowledge Base List
    ///
    /// Get a list of available knowledge base documents
    ///
    /// - Remark: HTTP `GET /v1/convai/knowledge-base`.
    /// - Remark: Generated from `#/paths//v1/convai/knowledge-base/get(Get_knowledge_base_list_v1_convai_knowledge_base_get)`.
    public func Get_knowledge_base_list_v1_convai_knowledge_base_get(_ input: Operations.Get_knowledge_base_list_v1_convai_knowledge_base_get.Input) async throws -> Operations.Get_knowledge_base_list_v1_convai_knowledge_base_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_knowledge_base_list_v1_convai_knowledge_base_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/knowledge-base",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "cursor",
                    value: input.query.cursor
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "page_size",
                    value: input.query.page_size
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_knowledge_base_list_v1_convai_knowledge_base_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetKnowledgeBaseListResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_knowledge_base_list_v1_convai_knowledge_base_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add To Knowledge Base
    ///
    /// Uploads a file or reference a webpage to use as part of the shared knowledge base
    ///
    /// - Remark: HTTP `POST /v1/convai/knowledge-base`.
    /// - Remark: Generated from `#/paths//v1/convai/knowledge-base/post(Add_to_knowledge_base_v1_convai_knowledge_base_post)`.
    public func Add_to_knowledge_base_v1_convai_knowledge_base_post(_ input: Operations.Add_to_knowledge_base_v1_convai_knowledge_base_post.Input) async throws -> Operations.Add_to_knowledge_base_v1_convai_knowledge_base_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_to_knowledge_base_v1_convai_knowledge_base_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/knowledge-base",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_to_knowledge_base_v1_convai_knowledge_base_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddKnowledgeBaseResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_to_knowledge_base_v1_convai_knowledge_base_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add To Knowledge Base
    ///
    /// Uploads a file or reference a webpage for the agent to use as part of it's knowledge base
    ///
    /// - Remark: HTTP `POST /v1/convai/add-to-knowledge-base`.
    /// - Remark: Generated from `#/paths//v1/convai/add-to-knowledge-base/post(Add_to_knowledge_base_v1_convai_add_to_knowledge_base_post)`.
    @available(*, deprecated)
    public func Add_to_knowledge_base_v1_convai_add_to_knowledge_base_post(_ input: Operations.Add_to_knowledge_base_v1_convai_add_to_knowledge_base_post.Input) async throws -> Operations.Add_to_knowledge_base_v1_convai_add_to_knowledge_base_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_to_knowledge_base_v1_convai_add_to_knowledge_base_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/add-to-knowledge-base",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_to_knowledge_base_v1_convai_add_to_knowledge_base_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddKnowledgeBaseResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_to_knowledge_base_v1_convai_add_to_knowledge_base_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add To Knowledge Base
    ///
    /// Uploads a file or reference a webpage for the agent to use as part of it's knowledge base
    ///
    /// - Remark: HTTP `POST /v1/convai/agents/{agent_id}/add-to-knowledge-base`.
    /// - Remark: Generated from `#/paths//v1/convai/agents/{agent_id}/add-to-knowledge-base/post(Add_to_knowledge_base_v1_convai_agents__agent_id__add_to_knowledge_base_post)`.
    @available(*, deprecated)
    public func Add_to_knowledge_base_v1_convai_agents__agent_id__add_to_knowledge_base_post(_ input: Operations.Add_to_knowledge_base_v1_convai_agents__agent_id__add_to_knowledge_base_post.Input) async throws -> Operations.Add_to_knowledge_base_v1_convai_agents__agent_id__add_to_knowledge_base_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_to_knowledge_base_v1_convai_agents__agent_id__add_to_knowledge_base_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/agents/{}/add-to-knowledge-base",
                    parameters: [
                        input.path.agent_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_to_knowledge_base_v1_convai_agents__agent_id__add_to_knowledge_base_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AddKnowledgeBaseResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_to_knowledge_base_v1_convai_agents__agent_id__add_to_knowledge_base_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Documentation From Knowledge Base
    ///
    /// Get details about a specific documentation making up the agent's knowledge base
    ///
    /// - Remark: HTTP `GET /v1/convai/knowledge-base/{documentation_id}`.
    /// - Remark: Generated from `#/paths//v1/convai/knowledge-base/{documentation_id}/get(Get_documentation_from_knowledge_base_v1_convai_knowledge_base__documentation_id__get)`.
    public func Get_documentation_from_knowledge_base_v1_convai_knowledge_base__documentation_id__get(_ input: Operations.Get_documentation_from_knowledge_base_v1_convai_knowledge_base__documentation_id__get.Input) async throws -> Operations.Get_documentation_from_knowledge_base_v1_convai_knowledge_base__documentation_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_documentation_from_knowledge_base_v1_convai_knowledge_base__documentation_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/knowledge-base/{}",
                    parameters: [
                        input.path.documentation_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_documentation_from_knowledge_base_v1_convai_knowledge_base__documentation_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetKnowledgeBaseResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_documentation_from_knowledge_base_v1_convai_knowledge_base__documentation_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Knowledge Base Document
    ///
    /// Delete a document from the knowledge base
    ///
    /// - Remark: HTTP `DELETE /v1/convai/knowledge-base/{documentation_id}`.
    /// - Remark: Generated from `#/paths//v1/convai/knowledge-base/{documentation_id}/delete(Delete_knowledge_base_document_v1_convai_knowledge_base__documentation_id__delete)`.
    public func Delete_knowledge_base_document_v1_convai_knowledge_base__documentation_id__delete(_ input: Operations.Delete_knowledge_base_document_v1_convai_knowledge_base__documentation_id__delete.Input) async throws -> Operations.Delete_knowledge_base_document_v1_convai_knowledge_base__documentation_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_knowledge_base_document_v1_convai_knowledge_base__documentation_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/knowledge-base/{}",
                    parameters: [
                        input.path.documentation_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_knowledge_base_document_v1_convai_knowledge_base__documentation_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_knowledge_base_document_v1_convai_knowledge_base__documentation_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Documentation From Knowledge Base
    ///
    /// Get details about a specific documentation making up the agent's knowledge base
    ///
    /// - Remark: HTTP `GET /v1/convai/agents/{agent_id}/knowledge-base/{documentation_id}`.
    /// - Remark: Generated from `#/paths//v1/convai/agents/{agent_id}/knowledge-base/{documentation_id}/get(Get_documentation_from_knowledge_base_v1_convai_agents__agent_id__knowledge_base__documentation_id__get)`.
    @available(*, deprecated)
    public func Get_documentation_from_knowledge_base_v1_convai_agents__agent_id__knowledge_base__documentation_id__get(_ input: Operations.Get_documentation_from_knowledge_base_v1_convai_agents__agent_id__knowledge_base__documentation_id__get.Input) async throws -> Operations.Get_documentation_from_knowledge_base_v1_convai_agents__agent_id__knowledge_base__documentation_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_documentation_from_knowledge_base_v1_convai_agents__agent_id__knowledge_base__documentation_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/agents/{}/knowledge-base/{}",
                    parameters: [
                        input.path.agent_id,
                        input.path.documentation_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_documentation_from_knowledge_base_v1_convai_agents__agent_id__knowledge_base__documentation_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.GetKnowledgeBaseResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_documentation_from_knowledge_base_v1_convai_agents__agent_id__knowledge_base__documentation_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Tools
    ///
    /// Get all available tools available in the workspace.
    ///
    /// - Remark: HTTP `GET /v1/convai/tools`.
    /// - Remark: Generated from `#/paths//v1/convai/tools/get(Get_tools_v1_convai_tools_get)`.
    public func Get_tools_v1_convai_tools_get(_ input: Operations.Get_tools_v1_convai_tools_get.Input) async throws -> Operations.Get_tools_v1_convai_tools_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_tools_v1_convai_tools_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/tools",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_tools_v1_convai_tools_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ToolsResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_tools_v1_convai_tools_get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Add Tool
    ///
    /// Add a new tool to the available tools in the workspace.
    ///
    /// - Remark: HTTP `POST /v1/convai/tools`.
    /// - Remark: Generated from `#/paths//v1/convai/tools/post(Add_tool_v1_convai_tools_post)`.
    public func Add_tool_v1_convai_tools_post(_ input: Operations.Add_tool_v1_convai_tools_post.Input) async throws -> Operations.Add_tool_v1_convai_tools_post.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Add_tool_v1_convai_tools_post.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/tools",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .post
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_tool_v1_convai_tools_post.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ToolResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Add_tool_v1_convai_tools_post.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Get Tool
    ///
    /// Get tool that is available in the workspace.
    ///
    /// - Remark: HTTP `GET /v1/convai/tools/{tool_id}`.
    /// - Remark: Generated from `#/paths//v1/convai/tools/{tool_id}/get(Get_tool_v1_convai_tools__tool_id__get)`.
    public func Get_tool_v1_convai_tools__tool_id__get(_ input: Operations.Get_tool_v1_convai_tools__tool_id__get.Input) async throws -> Operations.Get_tool_v1_convai_tools__tool_id__get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Get_tool_v1_convai_tools__tool_id__get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/tools/{}",
                    parameters: [
                        input.path.tool_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_tool_v1_convai_tools__tool_id__get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ToolResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Get_tool_v1_convai_tools__tool_id__get.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Update Tool
    ///
    /// Update tool that is available in the workspace.
    ///
    /// - Remark: HTTP `PATCH /v1/convai/tools/{tool_id}`.
    /// - Remark: Generated from `#/paths//v1/convai/tools/{tool_id}/patch(Update_tool_v1_convai_tools__tool_id__patch)`.
    public func Update_tool_v1_convai_tools__tool_id__patch(_ input: Operations.Update_tool_v1_convai_tools__tool_id__patch.Input) async throws -> Operations.Update_tool_v1_convai_tools__tool_id__patch.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Update_tool_v1_convai_tools__tool_id__patch.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/tools/{}",
                    parameters: [
                        input.path.tool_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .patch
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_tool_v1_convai_tools__tool_id__patch.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.ToolResponseModel.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Update_tool_v1_convai_tools__tool_id__patch.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Delete Tool
    ///
    /// Delete tool from the workspace.
    ///
    /// - Remark: HTTP `DELETE /v1/convai/tools/{tool_id}`.
    /// - Remark: Generated from `#/paths//v1/convai/tools/{tool_id}/delete(Delete_tool_v1_convai_tools__tool_id__delete)`.
    public func Delete_tool_v1_convai_tools__tool_id__delete(_ input: Operations.Delete_tool_v1_convai_tools__tool_id__delete.Input) async throws -> Operations.Delete_tool_v1_convai_tools__tool_id__delete.Output {
        try await client.send(
            input: input,
            forOperation: Operations.Delete_tool_v1_convai_tools__tool_id__delete.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v1/convai/tools/{}",
                    parameters: [
                        input.path.tool_id
                    ]
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .delete
                )
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "xi-api-key",
                    value: input.headers.xi_hyphen_api_hyphen_key
                )
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_tool_v1_convai_tools__tool_id__delete.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                case 422:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.Delete_tool_v1_convai_tools__tool_id__delete.Output.UnprocessableContent.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.HTTPValidationError.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .unprocessableContent(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
    /// Redirect To Mintlify
    ///
    /// - Remark: HTTP `GET /docs`.
    /// - Remark: Generated from `#/paths//docs/get(redirect_to_mintlify_docs_get)`.
    public func redirect_to_mintlify_docs_get(_ input: Operations.redirect_to_mintlify_docs_get.Input) async throws -> Operations.redirect_to_mintlify_docs_get.Output {
        try await client.send(
            input: input,
            forOperation: Operations.redirect_to_mintlify_docs_get.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/docs",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(
                    soar_path: path,
                    method: .get
                )
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(
                    in: &request.headerFields,
                    contentTypes: input.headers.accept
                )
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.redirect_to_mintlify_docs_get.Output.Ok.Body
                    let chosenContentType = try converter.bestContentType(
                        received: contentType,
                        options: [
                            "application/json"
                        ]
                    )
                    switch chosenContentType {
                    case "application/json":
                        body = try await converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: responseBody,
                            transforming: { value in
                                .json(value)
                            }
                        )
                    default:
                        preconditionFailure("bestContentType chose an invalid content type.")
                    }
                    return .ok(.init(body: body))
                default:
                    return .undocumented(
                        statusCode: response.status.code,
                        .init(
                            headerFields: response.headerFields,
                            body: responseBody
                        )
                    )
                }
            }
        )
    }
}
